lexicon: "!" "!!" "#" "%" "&" "&&&" "(" "()" "(|" ")" "*" "*â‡©R" "*â‡©iâ‡©nâ‡©t"
  "*â‡©râ‡©eâ‡©aâ‡©l" "+" "++" "+â‡©iâ‡©nâ‡©t" "+â‡©râ‡©eâ‡©aâ‡©l" "+â‡©sâ‡©tâ‡©râ‡©iâ‡©nâ‡©g" "," "-" "--" "---->"
  "--->" "-->" "->anyâ‡©Bâ‡©aâ‡©g()" "->anyâ‡©Sâ‡©eâ‡©q()" "->anyâ‡©Sâ‡©eâ‡©t()" "->appendâ‡©Sâ‡©eâ‡©q("
  "->asBooleanâ‡©Iâ‡©nâ‡©t()" "->asBooleanâ‡©Râ‡©eâ‡©aâ‡©l()" "->asIntegerâ‡©Râ‡©eâ‡©aâ‡©l()"
  "->asPairâ‡©Sâ‡©eâ‡©q()" "->asPairâ‡©Sâ‡©eâ‡©t()" "->asRealâ‡©Iâ‡©nâ‡©t()" "->asSequenceâ‡©Pâ‡©aâ‡©iâ‡©r()"
  "->asSequenceâ‡©Sâ‡©eâ‡©t()" "->asSetâ‡©Pâ‡©aâ‡©iâ‡©r()" "->asSetâ‡©Sâ‡©eâ‡©q()" "->atâ‡©Sâ‡©eâ‡©q("
  "->collectâ‡©Sâ‡©eâ‡©q(" "->countâ‡©Bâ‡©aâ‡©g(" "->countâ‡©Sâ‡©eâ‡©t(" "->excludesAllâ‡©Bâ‡©aâ‡©g("
  "->excludesAllâ‡©Sâ‡©eâ‡©t(" "->excludesâ‡©Bâ‡©aâ‡©g(" "->excludesâ‡©Sâ‡©eâ‡©t("
  "->excludingâ‡©Bâ‡©aâ‡©g(" "->excludingâ‡©Sâ‡©eâ‡©q(" "->excludingâ‡©Sâ‡©eâ‡©t(" "->existsâ‡©Bâ‡©aâ‡©g("
  "->existsâ‡©Sâ‡©eâ‡©q(" "->existsâ‡©Sâ‡©eâ‡©t(" "->firstâ‡©Sâ‡©eâ‡©q(" "->forAllâ‡©Bâ‡©aâ‡©g("
  "->forAllâ‡©Sâ‡©eâ‡©q(" "->forAllâ‡©Sâ‡©eâ‡©t(" "->includesAllâ‡©Bâ‡©aâ‡©g(" "->includesAllâ‡©Sâ‡©eâ‡©t("
  "->includesâ‡©Bâ‡©aâ‡©g(" "->includesâ‡©Sâ‡©eâ‡©t(" "->includingâ‡©Bâ‡©aâ‡©g(" "->includingâ‡©Sâ‡©eâ‡©q("
  "->includingâ‡©Sâ‡©eâ‡©t(" "->intersectionâ‡©Bâ‡©aâ‡©g(" "->intersectionâ‡©Sâ‡©eâ‡©t("
  "->isEmptyâ‡©Bâ‡©aâ‡©g()" "->isEmptyâ‡©Sâ‡©eâ‡©q()" "->isEmptyâ‡©Sâ‡©eâ‡©t()" "->iterateâ‡©Bâ‡©aâ‡©g("
  "->iterateâ‡©Sâ‡©eâ‡©q(" "->iterateâ‡©Sâ‡©eâ‡©t(" "->lastâ‡©Sâ‡©eâ‡©q(" "->notEmptyâ‡©Bâ‡©aâ‡©g()"
  "->notEmptyâ‡©Sâ‡©eâ‡©q()" "->notEmptyâ‡©Sâ‡©eâ‡©t()" "->oclIsModifiedOnly()"
  "->prependâ‡©Sâ‡©eâ‡©q(" "->rejectâ‡©Bâ‡©aâ‡©g(" "->rejectâ‡©Sâ‡©eâ‡©t(" "->selectâ‡©Bâ‡©aâ‡©g("
  "->selectâ‡©Sâ‡©eâ‡©q(" "->selectâ‡©Sâ‡©eâ‡©t(" "->sizeâ‡©Bâ‡©aâ‡©g()" "->sizeâ‡©Sâ‡©eâ‡©q()"
  "->sizeâ‡©Sâ‡©eâ‡©t()" "->sumâ‡©Bâ‡©aâ‡©g()" "->sumâ‡©Sâ‡©eâ‡©t()" "->unionâ‡©Bâ‡©aâ‡©g("
  "->unionâ‡©Sâ‡©eâ‡©q(" "->unionâ‡©Sâ‡©eâ‡©t(" "-â‡©iâ‡©nâ‡©t" "-â‡©râ‡©eâ‡©aâ‡©l" "-`" "." ".." "..." "..<"
  "..}" ".First()" ".Second()" ".allInstances()" ".allInstances@pre()"
  ".oclIsAbsent()" ".oclIsDeleted()" ".oclIsMaintained()" ".oclIsNew()" "/" "//"
  "/â‡©R" "0" "1" ":" "::" ":=" ":>" ";" "<" "<*>" "<*lex*>" "<*mlex*>" "<+>" "<-"
  "<->" "<.." "<..<" "<..}" "<=" "<>" "<â‡©iâ‡©nâ‡©t" "<â‡©râ‡©eâ‡©aâ‡©l" "=" "==" "==>" "=>"
  "=simp=>" ">" ">=" "?" "?!" "@" "@post" "@pre" "ALL" "Bag(" "Bag{" "Bag{}" "CHR"
  "CONST" "CSUM" "DERIV" "EX" "EX!" "FDERIV" "GREATEST" "INF" "INFM" "INT" "IâŸ¦"
  "Int" "LEAST" "LIM" "MOST" "O" "OFCLASS" "OO" "PROD" "PROP" "Pair(" "Pair{"
  "SIGMA" "SOME" "SORT_CONSTRAINT" "SUM" "SUP" "Sequence(" "Sequence{" "Sequence{}"
  "Set(" "Set{" "Set{}" "TERM" "THE" "TYPE" "TYPEREP" "UN" "Un" "WRT" "XCONST" "["
  "[â†¦]" "[]" "[|" "[|->]" "â‹€" "âˆ·" "â‹‚" "âŸ¹" "âˆ" "â‡’" "â¨…â‡©fâ‡©iâ‡©n" "â¨†â‡©fâ‡©iâ‡©n" "âˆ‘"
  "âŠ¨" "â‹ƒ" "â‡˜" "â‡™" "â‡§*" "â‡§*â‡§*" "â‡§+" "â‡§+â‡§+" "â‡§2" "â‡§=" "â‡§=â‡§=" "ğ–º" "âˆ§" "ğ–»" "Â¦" "âŠ¥" "ğ–¼"
  "âˆ˜" "âˆ˜â‡©m" "Î´" "â‰" "â€¦" "ğŸ´" "ğŸ´.ğŸ¬" "â‰¡" "âˆƒ" "âˆƒ!" "âˆƒâ‡©F" "âˆƒâ‡©âˆ" "ğŸ±" "ğŸ±.ğŸ¬" "âˆ€" "âˆ€â‡©F"
  "âˆ€â‡©âˆ" "ğŸ°" "ğŸ°.ğŸ¬" "â‰¥" "âˆˆ" "Ä±" "â„¤" "âˆ©" "Â¯" "Â¯Â¯" "Î»" "âŸ¨" "âŸ¦" "âŒˆ" "â‰¤" "â‰¤â‡©iâ‡©nâ‡©t"
  "â‰¤â‡©râ‡©eâ‡©aâ‡©l" "â†" "âŒŠ" "âŸ·" "âŸ¶" "â¦‡" "â†¦" "â„•" "ğŸµ" "ğŸµ.ğŸ¬" "Â¬" "â‰ " "âˆ‰" "ğŸ­" "ğŸ­.ğŸ¬" "ğŸ­ğŸ¬"
  "ğŸ­ğŸ¬.ğŸ¬" "âˆ¨" "Ï€" "âŸ©â‡©âŠ¥" "â„š" "âŸ§" "âŒ‰" "â„" "âŒ‹" "â‡€" "â¦ˆ" "ğŸ³" "ğŸ³.ğŸ¬" "ğŸ²" "ğŸ².ğŸ¬" "Ïµ" "â‹„" "âŠ‚"
  "âŠ†" "âŠ†â‡©m" "âŠƒ" "âŠ‡" "ğŸ¯" "ğŸ¯.ğŸ¬" "Ã—" "â‰œ" "ğŸ®" "ğŸ®.ğŸ¬" "âˆª" "Ï…" "ğŸ¬" "ğŸ¬.ğŸ¬" "]" "^" "^*"
  "^**" "^+" "^++" "^--1" "^-1" "^=" "^==" "^^" "_" "_'" "`" "``" "and" "at" "case"
  "chainâ‡©âŠ†" "choose" "differentiable" "div" "divâ‡©iâ‡©nâ‡©t" "divâ‡©râ‡©eâ‡©aâ‡©l" "dvd" "else"
  "endif" "gchoose" "has_derivative" "has_field_derivative" "has_real_derivative"
  "has_vector_derivative" "if" "implies" "in" "initial_segment_of" "let" "mod"
  "modâ‡©iâ‡©nâ‡©t" "modâ‡©râ‡©eâ‡©aâ‡©l" "not" "o" "o_m" "of" "op" "or" "powr" "respects"
  "respects2" "sums" "then" "within" "{" "{.." "{..<" "{}" "|" "|)" "|->" "|â‰ " "|]"
  "|`" "}" "~" "~:" "~=" "~=>"
prods:
  Fun.updbind = any[0] ":=" any[0] => "_updbind" (1000)
  Fun.updbinds = Fun.updbind[0] "," Fun.updbinds[0] => "_updbinds" (1000)
  Fun.updbinds = Fun.updbind[-1] (-1)
  HOL.case_syn = any[0] "â‡’" any[0] => "_case1" (10)
  HOL.case_syn = any[0] "=>" any[0] => "_case1" (10)
  HOL.cases_syn = HOL.case_syn[0] "|" HOL.cases_syn[0] => "_case2" (1000)
  HOL.cases_syn = HOL.case_syn[-1] (-1)
  HOL.letbind = pttrn[0] "=" any[0] => "_bind" (10)
  HOL.letbinds = HOL.letbind[0] ";" HOL.letbinds[0] => "_binds" (1000)
  HOL.letbinds = HOL.letbind[-1] (-1)
  List.lc_qual = logic[0] => "_lc_test" (1000)
  List.lc_qual = any[0] "â†" logic[0] => "_lc_gen" (1000)
  List.lc_qual = any[0] "<-" logic[0] => "_lc_gen" (1000)
  List.lc_quals = "," List.lc_qual[0] List.lc_quals[0] => "_lc_quals" (1000)
  List.lc_quals = "]" => "_lc_end" (1000)
  List.lupdbind = any[0] ":=" any[0] => "_lupdbind" (1000)
  List.lupdbinds = List.lupdbind[0] "," List.lupdbinds[0] => "_lupdbinds" (1000)
  List.lupdbinds = List.lupdbind[-1] (-1)
  Map.maplet = any[0] "â†¦" any[0] => "_maplet" (1000)
  Map.maplet = any[0] "[â†¦]" any[0] => "_maplets" (1000)
  Map.maplet = any[0] "|->" any[0] => "_maplet" (1000)
  Map.maplet = any[0] "[|->]" any[0] => "_maplets" (1000)
  Map.maplets = Map.maplet[0] "," Map.maplets[0] => "_Maplets" (1000)
  Map.maplets = Map.maplet[-1] (-1)
  Product_Type.patterns = pttrn[0] "," Product_Type.patterns[0] => "_patterns"
    (1000)
  Product_Type.patterns = pttrn[-1] (-1)
  Product_Type.tuple_args = any[0] => "_tuple_arg" (1000)
  Product_Type.tuple_args = any[0] "," Product_Type.tuple_args[0] => "_tuple_args"
    (1000)
  Record.field = Record.ident[0] "=" any[0] => "_field" (1000)
  Record.field_type = Record.ident[0] "::" type[0] => "_field_type" (1000)
  Record.field_types = Record.field_type[0] "," Record.field_types[0]
    => "_field_types" (1000)
  Record.field_types = Record.field_type[-1] (-1)
  Record.field_update = Record.ident[0] ":=" any[0] => "_field_update" (1000)
  Record.field_updates = Record.field_update[0] "," Record.field_updates[0]
    => "_field_updates" (1000)
  Record.field_updates = Record.field_update[-1] (-1)
  Record.fields = Record.field[0] "," Record.fields[0] => "_fields" (1000)
  Record.fields = Record.field[-1] (-1)
  Record.ident = longid => "_constify" (1000)
  Record.ident = id => "_constify" (1000)
  any = prop'[-1] (-1)
  any = logic[-1] (-1)
  aprop = "_" => "\<^const>Pure.dummy_pattern" (1000)
  aprop = "XCONST" longid_position[0] => "_context_xconst" (1000)
  aprop = "XCONST" id_position[0] => "_context_xconst" (1000)
  aprop = "CONST" longid_position[0] => "_context_const" (1000)
  aprop = "CONST" id_position[0] => "_context_const" (1000)
  aprop = "..." => "_DDDOT" (1000)
  aprop = "(" aprop[0] ")" (1000)
  aprop = "â€¦" => "_DDDOT" (1000)
  aprop = logic[1000] cargs[1000] => "_applC" (999)
  aprop = var_position[-1] (-1)
  aprop = longid_position[-1] (-1)
  aprop = id_position[-1] (-1)
  args = any[0] "," args[0] => "_args" (1000)
  args = any[-1] (-1)
  asms = prop[0] ";" asms[0] => "_asms" (1000)
  asms = prop[0] => "_asm" (1000)
  cargs = any[1000] cargs[1000] => "_cargs" (1000)
  cargs = any[-1] (-1)
  cartouche_position = cartouche => "_position" (1000)
  class_name = longid => "_class_name" (1000)
  class_name = id => "_class_name" (1000)
  classes = class_name[0] "," classes[0] => "_classes" (1000)
  classes = class_name[-1] (-1)
  float_const = float_position[0] => "_constify" (1000)
  float_position = float_token => "_position" (1000)
  id_position = id => "_position" (1000)
  idt = "(" idt[0] ")" (1000)
  idt = "_" "::" type[0] => "_idtypdummy" (0)
  idt = "_" => "_idtdummy" (1000)
  idt = "_" "âˆ·" type[0] => "_idtypdummy" (0)
  idt = id_position[0] "::" type[0] => "_idtyp" (0)
  idt = id_position[0] "âˆ·" type[0] => "_idtyp" (0)
  idt = id_position[-1] (-1)
  idts = idt[1] idts[0] => "_idts" (0)
  idts = idt[-1] (-1)
  index = "Ä±" => "_indexvar" (1000)
  index = => "_indexdefault" (1000)
  index = "â‡˜" logic[0] "â‡™" => "_index" (1000)
  logic = "op" "&&&" => "\<^const>Pure.conjunction" (1000)
  logic = "op" "==>" => "\<^const>Pure.imp" (1000)
  logic = "op" "âŸ¹" => "\<^const>Pure.imp" (1000)
  logic = "op" "â‰¡" => "\<^const>Pure.eq" (1000)
  logic = "op" "==" => "\<^const>Pure.eq" (1000)
  logic = "op" "-->" => "\<^const>HOL.implies" (1000)
  logic = "op" "=" => "\<^const>HOL.eq" (1000)
  logic = "op" "|" => "\<^const>HOL.disj" (1000)
  logic = "op" "&" => "\<^const>HOL.conj" (1000)
  logic = "op" "~=" => "\<^const>HOL.not_equal" (1000)
  logic = "op" "â‰ " => "\<^const>HOL.not_equal" (1000)
  logic = "op" "âŸ¶" => "\<^const>HOL.implies" (1000)
  logic = "op" "âˆ¨" => "\<^const>HOL.disj" (1000)
  logic = "op" "âˆ§" => "\<^const>HOL.conj" (1000)
  logic = "op" "<->" => "\<^const>HOL.iff" (1000)
  logic = "op" "âŸ·" => "\<^const>HOL.iff" (1000)
  logic = "op" "=simp=>" => "\<^const>HOL.simp_implies" (1000)
  logic = "op" "<" => "\<^const>Orderings.ord_class.less" (1000)
  logic = "op" "<=" => "\<^const>Orderings.ord_class.less_eq" (1000)
  logic = "op" "â‰¤" => "\<^const>Orderings.ord_class.less_eq" (1000)
  logic = "op" ">=" => "\<^const>Orderings.ord_class.greater_eq" (1000)
  logic = "op" "â‰¥" => "\<^const>Orderings.ord_class.greater_eq" (1000)
  logic = "op" ">" => "\<^const>Orderings.ord_class.greater" (1000)
  logic = "op" "+" => "\<^const>Groups.plus_class.plus" (1000)
  logic = "op" "-" => "\<^const>Groups.minus_class.minus" (1000)
  logic = "op" "*" => "\<^const>Groups.times_class.times" (1000)
  logic = "op" ":" => "\<^const>Set.member" (1000)
  logic = "op" "~:" => "\<^const>Set.not_member" (1000)
  logic = "op" "âˆ‰" => "\<^const>Set.not_member" (1000)
  logic = "op" "âˆˆ" => "\<^const>Set.member" (1000)
  logic = "op" "âŠ†" => "\<^const>Set.subset_eq" (1000)
  logic = "op" "âŠ‚" => "\<^const>Set.subset" (1000)
  logic = "op" "âŠ‡" => "\<^const>Set.supset_eq" (1000)
  logic = "op" "âŠƒ" => "\<^const>Set.supset" (1000)
  logic = "op" "Int" => "\<^const>Set.inter" (1000)
  logic = "op" "âˆ©" => "\<^const>Set.inter" (1000)
  logic = "op" "Un" => "\<^const>Set.union" (1000)
  logic = "op" "âˆª" => "\<^const>Set.union" (1000)
  logic = "op" "`" => "\<^const>Set.image" (1000)
  logic = "op" "-`" => "\<^const>Set.vimage" (1000)
  logic = "op" "o" => "\<^const>Fun.comp" (1000)
  logic = "op" "âˆ˜" => "\<^const>Fun.comp" (1000)
  logic = "op" "<*>" => "\<^const>Product_Type.Times" (1000)
  logic = "op" "Ã—" => "\<^const>Product_Type.Times" (1000)
  logic = "op" "<+>" => "\<^const>Sum_Type.Plus" (1000)
  logic = "op" "dvd" => "\<^const>Rings.dvd_class.dvd" (1000)
  logic = "op" "/" => "\<^const>Fields.inverse_class.divide" (1000)
  logic = "op" "^^" => "\<^const>Nat.compower" (1000)
  logic = "op" "O" => "\<^const>Relation.relcomp" (1000)
  logic = "op" "OO" => "\<^const>Relation.relcompp" (1000)
  logic = "op" "``" => "\<^const>Relation.Image" (1000)
  logic = "op" "<*lex*>" => "\<^const>Wellfounded.lex_prod" (1000)
  logic = "op" "<*mlex*>" => "\<^const>Wellfounded.mlex_prod" (1000)
  logic = "op" "initial_segment_of" => "\<^const>Zorn.initialSegmentOf" (1000)
  logic = "op" "//" => "\<^const>Equiv_Relations.quotient" (1000)
  logic = "op" "respects" => "\<^const>Equiv_Relations.RESPECTS" (1000)
  logic = "op" "respects2" => "\<^const>Equiv_Relations.RESPECTS2" (1000)
  logic = "op" "^" => "\<^const>Power.power_class.power" (1000)
  logic = "op" "div" => "\<^const>Divides.div_class.div" (1000)
  logic = "op" "mod" => "\<^const>Divides.div_class.mod" (1000)
  logic = "op" "#" => "\<^const>List.list.Cons" (1000)
  logic = "op" "@" => "\<^const>List.append" (1000)
  logic = "op" "!" => "\<^const>List.nth" (1000)
  logic = "op" "o_m" => "\<^const>Map.map_comp" (1000)
  logic = "op" "âˆ˜â‡©m" => "\<^const>Map.map_comp" (1000)
  logic = "op" "++" => "\<^const>Map.map_add" (1000)
  logic = "op" "|`" => "\<^const>Map.restrict_map" (1000)
  logic = "op" "âŠ†â‡©m" => "\<^const>Map.map_le" (1000)
  logic = "op" "choose" => "\<^const>Binomial.binomial" (1000)
  logic = "op" "gchoose" => "\<^const>Binomial.gbinomial" (1000)
  logic = "op" "--->"
    => "\<^const>Topological_Spaces.topological_space_class.tendsto" (1000)
  logic = "op" "*â‡©R" => "\<^const>Real_Vector_Spaces.scaleR_class.scaleR" (1000)
  logic = "op" "/â‡©R" => "\<^const>Real_Vector_Spaces.scaleR_class.divideR" (1000)
  logic = "op" "sums" => "\<^const>Series.sums" (1000)
  logic = "op" "has_derivative" => "\<^const>Deriv.has_derivative" (1000)
  logic = "op" "has_field_derivative" => "\<^const>Deriv.has_field_derivative"
    (1000)
  logic = "op" "has_vector_derivative" => "\<^const>Deriv.has_vector_derivative"
    (1000)
  logic = "op" "differentiable" => "\<^const>Deriv.differentiable" (1000)
  logic = "op" "has_real_derivative" => "\<^const>Deriv.has_real_derivative" (1000)
  logic = "op" "powr" => "\<^const>Transcendental.powr" (1000)
  logic = "op" "â‰œ" => "\<^const>UML_Logic.StrongEq" (1000)
  logic = "op" "and" => "\<^const>UML_Logic.OclAnd" (1000)
  logic = "op" "or" => "\<^const>UML_Logic.OclOr" (1000)
  logic = "op" "implies" => "\<^const>UML_Logic.OclImplies" (1000)
  logic = "op" "â‰" => "\<^const>UML_Logic.StrictRefEq" (1000)
  logic = "op" "<>" => "notequal" (1000)
  logic = "op" "+â‡©iâ‡©nâ‡©t" => "\<^const>UML_Integer.OclAddâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (1000)
  logic = "op" "-â‡©iâ‡©nâ‡©t" => "\<^const>UML_Integer.OclMinusâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (1000)
  logic = "op" "*â‡©iâ‡©nâ‡©t" => "\<^const>UML_Integer.OclMultâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (1000)
  logic = "op" "divâ‡©iâ‡©nâ‡©t" => "\<^const>UML_Integer.OclDivisionâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r"
    (1000)
  logic = "op" "modâ‡©iâ‡©nâ‡©t" => "\<^const>UML_Integer.OclModulusâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r"
    (1000)
  logic = "op" "<â‡©iâ‡©nâ‡©t" => "\<^const>UML_Integer.OclLessâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (1000)
  logic = "op" "â‰¤â‡©iâ‡©nâ‡©t" => "\<^const>UML_Integer.OclLeâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (1000)
  logic = "op" "+â‡©sâ‡©tâ‡©râ‡©iâ‡©nâ‡©g" => "\<^const>UML_String.OclAddâ‡©Sâ‡©tâ‡©râ‡©iâ‡©nâ‡©g" (1000)
  logic = "op" "+â‡©râ‡©eâ‡©aâ‡©l" => "\<^const>UML_Real.OclAddâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = "op" "-â‡©râ‡©eâ‡©aâ‡©l" => "\<^const>UML_Real.OclMinusâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = "op" "*â‡©râ‡©eâ‡©aâ‡©l" => "\<^const>UML_Real.OclMultâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = "op" "divâ‡©râ‡©eâ‡©aâ‡©l" => "\<^const>UML_Real.OclDivisionâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = "op" "modâ‡©râ‡©eâ‡©aâ‡©l" => "\<^const>UML_Real.OclModulusâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = "op" "<â‡©râ‡©eâ‡©aâ‡©l" => "\<^const>UML_Real.OclLessâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = "op" "â‰¤â‡©râ‡©eâ‡©aâ‡©l" => "\<^const>UML_Real.OclLeâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = "XCONST" longid_position[0] => "_context_xconst" (1000)
  logic = "XCONST" id_position[0] => "_context_xconst" (1000)
  logic = "CONST" longid_position[0] => "_context_const" (1000)
  logic = "CONST" id_position[0] => "_context_const" (1000)
  logic = "â‹„" index[1000] => "_struct" (1000)
  logic = "..." => "_DDDOT" (1000)
  logic = "TYPE" "(" type[0] ")" => "_TYPE" (1000)
  logic = "%" pttrns[0] "." any[3] => "_lambda" (3)
  logic = "%" HOL.cases_syn[0] => "_lam_pats_syntax" (10)
  logic = "(" logic[0] ")" (1000)
  logic = "(" any[0] "," Product_Type.tuple_args[0] ")" => "_tuple" (1000)
  logic = "â€¦" => "_DDDOT" (1000)
  logic = "Î»" pttrns[0] "." any[3] => "_lambda" (3)
  logic = "Î»" HOL.cases_syn[0] => "_lam_pats_syntax" (10)
  logic = "_" => "\<^const>Pure.dummy_pattern" (1000)
  logic = "EX!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "EX!" pttrn[0] ":" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "EX" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "EX" idt[0] ">=" any[0] "." logic[10] => "_Ex_greater_eq" (10)
  logic = "EX" idt[0] ">" any[0] "." logic[10] => "_Ex_greater" (10)
  logic = "EX" idt[0] "<=" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "EX" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "EX" pttrn[0] ":" logic[0] "." logic[10] => "_Bex" (10)
  logic = "ALL" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "ALL" idt[0] ">=" any[0] "." logic[10] => "_All_greater_eq" (10)
  logic = "ALL" idt[0] ">" any[0] "." logic[10] => "_All_greater" (10)
  logic = "ALL" idt[0] "<=" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "ALL" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "ALL" pttrn[0] ":" logic[0] "." logic[10] => "_Ball" (10)
  logic = "~" logic[40] => "\<^const>HOL.Not" (40)
  logic = "Â¬" logic[40] => "\<^const>HOL.Not" (40)
  logic = "THE" pttrn[0] "." logic[10] => "_The" (10)
  logic = "let" HOL.letbinds[0] "in" any[10] => "_Let" (10)
  logic = "case" any[0] "of" HOL.cases_syn[0] => "_case_syntax" (10)
  logic = "âˆƒ!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "âˆƒ!" pttrn[0] "âˆˆ" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "âˆƒ!" idt[0] "âŠ†" any[0] "." logic[10] => "_setleEx1" (10)
  logic = "âˆƒ" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "âˆƒ" idt[0] "â‰¥" any[0] "." logic[10] => "_Ex_greater_eq" (10)
  logic = "âˆƒ" idt[0] ">" any[0] "." logic[10] => "_Ex_greater" (10)
  logic = "âˆƒ" idt[0] "â‰¤" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "âˆƒ" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "âˆƒ" pttrn[0] "âˆˆ" logic[0] "." logic[10] => "_Bex" (10)
  logic = "âˆƒ" idt[0] "âŠ†" any[0] "." logic[10] => "_setleEx" (10)
  logic = "âˆƒ" idt[0] "âŠ‚" any[0] "." logic[10] => "_setlessEx" (10)
  logic = "âˆ€" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "âˆ€" idt[0] "â‰¥" any[0] "." logic[10] => "_All_greater_eq" (10)
  logic = "âˆ€" idt[0] ">" any[0] "." logic[10] => "_All_greater" (10)
  logic = "âˆ€" idt[0] "â‰¤" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "âˆ€" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "âˆ€" pttrn[0] "âˆˆ" logic[0] "." logic[10] => "_Ball" (10)
  logic = "âˆ€" idt[0] "âŠ†" any[0] "." logic[10] => "_setleAll" (10)
  logic = "âˆ€" idt[0] "âŠ‚" any[0] "." logic[10] => "_setlessAll" (10)
  logic = "?!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "?!" pttrn[0] ":" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "?" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "?" idt[0] "<=" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "?" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "?" pttrn[0] ":" logic[0] "." logic[10] => "_Bex" (10)
  logic = "!" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "!" idt[0] "<=" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "!" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "!" pttrn[0] ":" logic[0] "." logic[10] => "_Ball" (10)
  logic = "if" logic[0] "then" any[0] "else" any[10] => "\<^const>HOL.If" (10)
  logic = "if" logic[10] "then" logic[10] "else" logic[10] "endif"
    => "\<^const>UML_Logic.OclIf" (50)
  logic = "LEAST" idts[0] "." logic[10]
    => "\<^const>Orderings.ord_class.Least_binder" (10)
  logic = "LEAST" id ":" logic[0] "." logic[10] => "_Bleast" (10)
  logic = "LEAST" id "âˆˆ" logic[0] "." logic[10] => "_Bleast" (10)
  logic = "LEAST" pttrn[0] "WRT" logic[4] "." logic[10] => "_LeastM" (10)
  logic = "0" => "\<^const>Groups.zero_class.zero" (1000)
  logic = "-" any[81] => "\<^const>Groups.uminus_class.uminus" (80)
  logic = "Â¦" any[0] "Â¦" => "\<^const>Groups.abs_class.abs" (1000)
  logic = "1" => "\<^const>Groups.one_class.one" (1000)
  logic = "{" pttrn[0] "." logic[0] "}" => "_Coll" (1000)
  logic = "{" pttrn[0] ":" logic[0] "." logic[0] "}" => "_Collect" (1000)
  logic = "{" pttrn[0] "âˆˆ" logic[0] "." logic[0] "}" => "_Collect" (1000)
  logic = "{" args[0] "}" => "_Finset" (1000)
  logic = "{" any[0] "|" idts[0] "." logic[0] "}" => "_Setcompr" (1000)
  logic = "{" any[0] "<..}" => "\<^const>Set_Interval.ord_class.greaterThan" (1000)
  logic = "{" any[0] "..}" => "\<^const>Set_Interval.ord_class.atLeast" (1000)
  logic = "{" any[0] "<..<" any[0] "}"
    => "\<^const>Set_Interval.ord_class.greaterThanLessThan" (1000)
  logic = "{" any[0] "..<" any[0] "}"
    => "\<^const>Set_Interval.ord_class.atLeastLessThan" (1000)
  logic = "{" any[0] "<.." any[0] "}"
    => "\<^const>Set_Interval.ord_class.greaterThanAtMost" (1000)
  logic = "{" any[0] ".." any[0] "}"
    => "\<^const>Set_Interval.ord_class.atLeastAtMost" (1000)
  logic = "{}" => "\<^const>Set.empty" (1000)
  logic = "SUP" pttrn[0] ":" logic[0] "." any[10] => "_SUP" (10)
  logic = "SUP" pttrns[0] "." any[10] => "_SUP1" (10)
  logic = "INF" pttrn[0] ":" logic[0] "." any[10] => "_INF" (10)
  logic = "INF" pttrns[0] "." any[10] => "_INF1" (10)
  logic = "â‹‚" logic[900] => "\<^const>Complete_Lattices.Inter" (900)
  logic = "â‹‚" pttrn[0] "âˆˆ" logic[0] "." logic[10] => "_INTER" (10)
  logic = "â‹‚" pttrns[0] "." logic[10] => "_INTER1" (10)
  logic = "â‹‚" any[0] "<" any[0] "." logic[10] => "_INTER_less" (10)
  logic = "â‹‚" any[0] "â‰¤" any[0] "." logic[10] => "_INTER_le" (10)
  logic = "INT" pttrn[0] ":" logic[0] "." logic[10] => "_INTER" (10)
  logic = "INT" pttrns[0] "." logic[10] => "_INTER1" (10)
  logic = "INT" any[0] "<" any[0] "." logic[10] => "_INTER_less" (10)
  logic = "INT" any[0] "<=" any[0] "." logic[10] => "_INTER_le" (10)
  logic = "â‹ƒ" logic[900] => "\<^const>Complete_Lattices.Union" (900)
  logic = "â‹ƒ" pttrn[0] "âˆˆ" logic[0] "." logic[10] => "_UNION" (10)
  logic = "â‹ƒ" pttrns[0] "." logic[10] => "_UNION1" (10)
  logic = "â‹ƒ" any[0] "<" any[0] "." logic[10] => "_UNION_less" (10)
  logic = "â‹ƒ" any[0] "â‰¤" any[0] "." logic[10] => "_UNION_le" (10)
  logic = "UN" pttrn[0] ":" logic[0] "." logic[10] => "_UNION" (10)
  logic = "UN" pttrns[0] "." logic[10] => "_UNION1" (10)
  logic = "UN" any[0] "<" any[0] "." logic[10] => "_UNION_less" (10)
  logic = "UN" any[0] "<=" any[0] "." logic[10] => "_UNION_le" (10)
  logic = "()" => "\<^const>Product_Type.Unity" (1000)
  logic = "SIGMA" pttrn[0] ":" logic[0] "." logic[10] => "_Sigma" (10)
  logic = "â„•" => "\<^const>Nat.semiring_1_class.Nats" (1000)
  logic = "Ïµ" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "@" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "SOME" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "GREATEST" idts[0] "." logic[10]
    => "\<^const>Hilbert_Choice.Greatest_binder" (10)
  logic = "GREATEST" pttrn[0] "WRT" logic[4] "." logic[10] => "_GreatestM" (10)
  logic = "chainâ‡©âŠ†" => "\<^const>Zorn.chain_subset" (1000)
  logic = "CSUM" pttrn[0] ":" logic[51] "." logic[10] => "_Csum" (10)
  logic = num_const[0] => "_Numeral" (1000)
  logic = "âˆ‘" logic[1000] => "\<^const>Groups_Big.comm_monoid_add_class.Setsum"
    (999)
  logic = "âˆ‘" pttrn[0] "âˆˆ" logic[51] "." any[10] => "_setsum" (10)
  logic = "âˆ‘" pttrn[0] "|" logic[0] "." any[10] => "_qsetsum" (10)
  logic = "âˆ‘" idt[0] "â‰¤" any[0] "." any[10] => "_upto_setsum" (10)
  logic = "âˆ‘" idt[0] "<" any[0] "." any[10] => "_upt_setsum" (10)
  logic = "âˆ‘" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setsum"
    (10)
  logic = "âˆ‘" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setsum" (10)
  logic = "âˆ‘" pttrn[0] "â†" logic[51] "." any[10] => "_listsum" (10)
  logic = "âˆ‘" idts[0] "." any[10] => "\<^const>Series.suminf_binder" (10)
  logic = "SUM" pttrn[0] ":" logic[51] "." any[10] => "_setsum" (10)
  logic = "SUM" pttrn[0] "|" logic[0] "." any[10] => "_qsetsum" (10)
  logic = "SUM" idt[0] "<=" any[0] "." any[10] => "_upto_setsum" (10)
  logic = "SUM" idt[0] "<" any[0] "." any[10] => "_upt_setsum" (10)
  logic = "SUM" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setsum"
    (10)
  logic = "SUM" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setsum" (10)
  logic = "SUM" pttrn[0] "<-" logic[51] "." any[10] => "_listsum" (10)
  logic = "âˆ" logic[1000] => "\<^const>Groups_Big.comm_monoid_mult_class.Setprod"
    (999)
  logic = "âˆ" pttrn[0] "âˆˆ" logic[51] "." any[10] => "_setprod" (10)
  logic = "âˆ" pttrn[0] "|" logic[0] "." any[10] => "_qsetprod" (10)
  logic = "âˆ" idt[0] "â‰¤" any[0] "." any[10] => "_upto_setprod" (10)
  logic = "âˆ" idt[0] "<" any[0] "." any[10] => "_upt_setprod" (10)
  logic = "âˆ" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setprod"
    (10)
  logic = "âˆ" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setprod" (10)
  logic = "âˆ" pttrn[0] "â†" logic[51] "." any[10] => "_listprod" (10)
  logic = "PROD" pttrn[0] ":" logic[51] "." any[10] => "_setprod" (10)
  logic = "PROD" pttrn[0] "|" logic[0] "." any[10] => "_qsetprod" (10)
  logic = "PROD" idt[0] "<=" any[0] "." any[10] => "_upto_setprod" (10)
  logic = "PROD" idt[0] "<" any[0] "." any[10] => "_upt_setprod" (10)
  logic = "PROD" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setprod"
    (10)
  logic = "PROD" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setprod"
    (10)
  logic = "PROD" pttrn[0] "<-" logic[51] "." any[10] => "_listprod" (10)
  logic = "â„¤" => "\<^const>Int.ring_1_class.Ints" (1000)
  logic = "â¨…â‡©fâ‡©iâ‡©n" logic[900]
    => "\<^const>Lattices_Big.semilattice_inf_class.Inf_fin" (900)
  logic = "â¨†â‡©fâ‡©iâ‡©n" logic[900]
    => "\<^const>Lattices_Big.semilattice_sup_class.Sup_fin" (900)
  logic = "{..<" any[0] "}" => "\<^const>Set_Interval.ord_class.lessThan" (1000)
  logic = "{.." any[0] "}" => "\<^const>Set_Interval.ord_class.atMost" (1000)
  logic = "[]" => "\<^const>List.list.Nil" (1000)
  logic = "[" args[0] "]" => "_list" (1000)
  logic = "[" pttrn[0] "<-" logic[0] "." logic[0] "]" => "_filter" (1000)
  logic = "[" pttrn[0] "â†" logic[0] "." logic[0] "]" => "_filter" (1000)
  logic = "[" logic[0] "..<" logic[0] "]" => "\<^const>List.upt" (1000)
  logic = "[" any[0] "." List.lc_qual[0] List.lc_quals[0] => "_listcompr" (1000)
  logic = "[" logic[0] ".." logic[0] "]" => "\<^const>List.upto" (1000)
  logic = "[" Map.maplets[0] "]" => "_Map" (1000)
  logic = "CHR" str_position[0] => "_Char" (1000)
  logic = str_position[0] => "_String" (1000)
  logic = "TYPEREP" "(" type[0] ")" => "_TYPEREP" (1000)
  logic = "(|" Record.fields[0] "," "..." "=" any[0] "|)" => "_record_scheme"
    (1000)
  logic = "(|" Record.fields[0] "|)" => "_record" (1000)
  logic = "â¦‡" Record.fields[0] "," "â€¦" "=" any[0] "â¦ˆ" => "_record_scheme" (1000)
  logic = "â¦‡" Record.fields[0] "â¦ˆ" => "_record" (1000)
  logic = "âˆ€â‡©F" pttrn[0] "in" logic[0] "." logic[10] => "_eventually" (10)
  logic = "âˆƒâ‡©F" pttrn[0] "in" logic[0] "." logic[10] => "_frequently" (10)
  logic = "INFM" idts[0] "." logic[10] => "\<^const>Filter.Inf_many_binder" (10)
  logic = "MOST" idts[0] "." logic[10] => "\<^const>Filter.Alm_all_binder" (10)
  logic = "âˆ€â‡©âˆ" idts[0] "." logic[10] => "\<^const>Filter.Alm_all_binder" (10)
  logic = "âˆƒâ‡©âˆ" idts[0] "." logic[10] => "\<^const>Filter.Inf_many_binder" (10)
  logic = "LIM" pttrns[1000] any[10] "." any[0] ":>" any[10] => "_LIM" (10)
  logic = "â„š" => "\<^const>Rat.field_char_0_class.Rats" (1000)
  logic = float_const[0] => "_Float" (1000)
  logic = "at" any[1000] "within" logic[60]
    => "\<^const>Topological_Spaces.topological_space_class.at_within" (60)
  logic = "at" => "\<^const>Topological_Spaces.topological_space_class.at" (1000)
  logic = "â„" => "\<^const>Real_Vector_Spaces.Reals" (1000)
  logic = "FDERIV" logic[1000] any[1000] ":>" logic[60] => "\<^const>Deriv.FDERIV"
    (60)
  logic = "DERIV" logic[1000] any[1000] ":>" any[60] => "\<^const>Deriv.DERIV" (60)
  logic = "âŒŠ" any[0] "âŒ‹" => "\<^const>Option.option.Some" (1000)
  logic = "âŒˆ" logic[0] "âŒ‰" => "\<^const>UML_Types.drop" (1000)
  logic = "IâŸ¦" any[0] "âŸ§" => "\<^const>UML_Types.Sem" (1000)
  logic = "Ï…" logic[100] => "\<^const>UML_Logic.valid" (100)
  logic = "Î´" logic[100] => "\<^const>UML_Logic.defined" (100)
  logic = "not" => "\<^const>UML_Logic.OclNot" (1000)
  logic = "âŠ¥" => "\<^const>UML_Types.bot_class.bot" (1000)
  logic = "âŠ¥" => "\<^const>Option.option.None" (1000)
  logic = "Pair{" logic[0] "," logic[0] "}" => "\<^const>UML_Pair.OclPair" (1000)
  logic = "ğŸ¬" => "\<^const>UML_Integer.OclInt0" (1000)
  logic = "ğŸ­" => "\<^const>UML_Integer.OclInt1" (1000)
  logic = "ğŸ®" => "\<^const>UML_Integer.OclInt2" (1000)
  logic = "ğŸ¯" => "\<^const>UML_Integer.OclInt3" (1000)
  logic = "ğŸ°" => "\<^const>UML_Integer.OclInt4" (1000)
  logic = "ğŸ±" => "\<^const>UML_Integer.OclInt5" (1000)
  logic = "ğŸ²" => "\<^const>UML_Integer.OclInt6" (1000)
  logic = "ğŸ³" => "\<^const>UML_Integer.OclInt7" (1000)
  logic = "ğŸ´" => "\<^const>UML_Integer.OclInt8" (1000)
  logic = "ğŸµ" => "\<^const>UML_Integer.OclInt9" (1000)
  logic = "ğŸ­ğŸ¬" => "\<^const>UML_Integer.OclInt10" (1000)
  logic = "Bag{}" => "\<^const>UML_Bag.mtBag" (1000)
  logic = "Bag{" args[0] "}" => "_OclFinbag" (1000)
  logic = "ğ–º" => "\<^const>UML_String.OclStringa" (1000)
  logic = "ğ–»" => "\<^const>UML_String.OclStringb" (1000)
  logic = "ğ–¼" => "\<^const>UML_String.OclStringc" (1000)
  logic = "ğŸ¬.ğŸ¬" => "\<^const>UML_Real.OclReal0" (1000)
  logic = "ğŸ­.ğŸ¬" => "\<^const>UML_Real.OclReal1" (1000)
  logic = "ğŸ®.ğŸ¬" => "\<^const>UML_Real.OclReal2" (1000)
  logic = "ğŸ¯.ğŸ¬" => "\<^const>UML_Real.OclReal3" (1000)
  logic = "ğŸ°.ğŸ¬" => "\<^const>UML_Real.OclReal4" (1000)
  logic = "ğŸ±.ğŸ¬" => "\<^const>UML_Real.OclReal5" (1000)
  logic = "ğŸ².ğŸ¬" => "\<^const>UML_Real.OclReal6" (1000)
  logic = "ğŸ³.ğŸ¬" => "\<^const>UML_Real.OclReal7" (1000)
  logic = "ğŸ´.ğŸ¬" => "\<^const>UML_Real.OclReal8" (1000)
  logic = "ğŸµ.ğŸ¬" => "\<^const>UML_Real.OclReal9" (1000)
  logic = "ğŸ­ğŸ¬.ğŸ¬" => "\<^const>UML_Real.OclReal10" (1000)
  logic = "Ï€" => "\<^const>UML_Real.OclRealpi" (1000)
  logic = "Set{}" => "\<^const>UML_Set.mtSet" (1000)
  logic = "Set{" args[0] "}" => "_OclFinset" (1000)
  logic = "Sequence{}" => "\<^const>UML_Sequence.mtSequence" (1000)
  logic = "Sequence{" args[0] "}" => "_OclFinsequence" (1000)
  logic = cartouche_position[0] => "_cartouche_oclstring" (1000)
  logic = "_'" => "_ocl_denotation" (1000)
  logic = logic[0] "->asSequenceâ‡©Pâ‡©aâ‡©iâ‡©r()"
    => "\<^const>UML_Library.OclAsSeqâ‡©Pâ‡©aâ‡©iâ‡©r" (1000)
  logic = logic[0] "->asSequenceâ‡©Sâ‡©eâ‡©t()" => "\<^const>UML_Library.OclAsSeqâ‡©Sâ‡©eâ‡©t"
    (1000)
  logic = logic[0] "->asSetâ‡©Pâ‡©aâ‡©iâ‡©r()" => "\<^const>UML_Library.OclAsSetâ‡©Pâ‡©aâ‡©iâ‡©r"
    (1000)
  logic = logic[0] "->asSetâ‡©Sâ‡©eâ‡©q()" => "\<^const>UML_Library.OclAsSetâ‡©Sâ‡©eâ‡©q"
    (1000)
  logic = logic[0] "->asPairâ‡©Sâ‡©eâ‡©t()" => "\<^const>UML_Library.OclAsPairâ‡©Sâ‡©eâ‡©t"
    (1000)
  logic = logic[0] "->asPairâ‡©Sâ‡©eâ‡©q()" => "\<^const>UML_Library.OclAsPairâ‡©Sâ‡©eâ‡©q"
    (1000)
  logic = logic[0] "->asRealâ‡©Iâ‡©nâ‡©t()" => "\<^const>UML_Library.OclAsRealâ‡©Iâ‡©nâ‡©t"
    (1000)
  logic = logic[0] "->asIntegerâ‡©Râ‡©eâ‡©aâ‡©l()"
    => "\<^const>UML_Library.OclAsIntegerâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = logic[0] "->asBooleanâ‡©Râ‡©eâ‡©aâ‡©l()"
    => "\<^const>UML_Library.OclAsBooleanâ‡©Râ‡©eâ‡©aâ‡©l" (1000)
  logic = logic[0] "->asBooleanâ‡©Iâ‡©nâ‡©t()"
    => "\<^const>UML_Library.OclAsBooleanâ‡©Iâ‡©nâ‡©t" (1000)
  logic = logic[0] "->anyâ‡©Sâ‡©eâ‡©q()" => "\<^const>UML_Sequence.OclANY" (1000)
  logic = logic[0] "->notEmptyâ‡©Sâ‡©eâ‡©q()" => "\<^const>UML_Sequence.OclNotEmpty"
    (1000)
  logic = logic[0] "->isEmptyâ‡©Sâ‡©eâ‡©q()" => "\<^const>UML_Sequence.OclIsEmpty" (1000)
  logic = logic[0] "->sizeâ‡©Sâ‡©eâ‡©q()" => "\<^const>UML_Sequence.OclSize" (1000)
  logic = logic[0] "->selectâ‡©Sâ‡©eâ‡©q(" id "|" logic[0] ")" => "_OclSelectSeq" (1000)
  logic = logic[0] "->collectâ‡©Sâ‡©eâ‡©q(" id "|" logic[0] ")" => "_OclCollectSeq"
    (1000)
  logic = logic[0] "->existsâ‡©Sâ‡©eâ‡©q(" id "|" logic[0] ")" => "_OclExistSeq" (1000)
  logic = logic[0] "->forAllâ‡©Sâ‡©eâ‡©q(" id "|" logic[0] ")" => "_OclForallSeq" (1000)
  logic = logic[0] "->iterateâ‡©Sâ‡©eâ‡©q(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")"
    => "_OclIterateSeq" (1000)
  logic = logic[0] "->lastâ‡©Sâ‡©eâ‡©q(" logic[0] ")" => "\<^const>UML_Sequence.OclLast"
    (1000)
  logic = logic[0] "->firstâ‡©Sâ‡©eâ‡©q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclFirst" (1000)
  logic = logic[0] "->atâ‡©Sâ‡©eâ‡©q(" logic[0] ")" => "\<^const>UML_Sequence.OclAt"
    (1000)
  logic = logic[0] "->unionâ‡©Sâ‡©eâ‡©q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclUnion" (1000)
  logic = logic[0] "->appendâ‡©Sâ‡©eâ‡©q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclAppend" (1000)
  logic = logic[0] "->excludingâ‡©Sâ‡©eâ‡©q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclExcluding" (1000)
  logic = logic[0] "->includingâ‡©Sâ‡©eâ‡©q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclIncluding" (1000)
  logic = logic[0] "->prependâ‡©Sâ‡©eâ‡©q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclPrepend" (1000)
  logic = logic[0] "->sumâ‡©Sâ‡©eâ‡©t()" => "\<^const>UML_Set.OclSum" (1000)
  logic = logic[0] "->countâ‡©Sâ‡©eâ‡©t(" logic[0] ")" => "\<^const>UML_Set.OclCount"
    (1000)
  logic = logic[0] "->intersectionâ‡©Sâ‡©eâ‡©t(" logic[0] ")"
    => "\<^const>UML_Set.OclIntersection" (1000)
  logic = logic[0] "->unionâ‡©Sâ‡©eâ‡©t(" logic[0] ")" => "\<^const>UML_Set.OclUnion"
    (1000)
  logic = logic[0] "->excludesAllâ‡©Sâ‡©eâ‡©t(" logic[0] ")"
    => "\<^const>UML_Set.OclExcludesAll" (1000)
  logic = logic[0] "->includesAllâ‡©Sâ‡©eâ‡©t(" logic[0] ")"
    => "\<^const>UML_Set.OclIncludesAll" (1000)
  logic = logic[0] "->rejectâ‡©Sâ‡©eâ‡©t(" id "|" logic[0] ")" => "_OclRejectSet" (1000)
  logic = logic[0] "->selectâ‡©Sâ‡©eâ‡©t(" id "|" logic[0] ")" => "_OclSelectSet" (1000)
  logic = logic[0] "->iterateâ‡©Sâ‡©eâ‡©t(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")"
    => "_OclIterateSet" (1000)
  logic = logic[0] "->existsâ‡©Sâ‡©eâ‡©t(" id "|" logic[0] ")" => "_OclExistSet" (1000)
  logic = logic[0] "->forAllâ‡©Sâ‡©eâ‡©t(" id "|" logic[0] ")" => "_OclForallSet" (1000)
  logic = logic[0] "->anyâ‡©Sâ‡©eâ‡©t()" => "\<^const>UML_Set.OclANY" (1000)
  logic = logic[0] "->notEmptyâ‡©Sâ‡©eâ‡©t()" => "\<^const>UML_Set.OclNotEmpty" (1000)
  logic = logic[0] "->isEmptyâ‡©Sâ‡©eâ‡©t()" => "\<^const>UML_Set.OclIsEmpty" (1000)
  logic = logic[0] "->sizeâ‡©Sâ‡©eâ‡©t()" => "\<^const>UML_Set.OclSize" (1000)
  logic = logic[0] "->excludesâ‡©Sâ‡©eâ‡©t(" logic[0] ")"
    => "\<^const>UML_Set.OclExcludes" (1000)
  logic = logic[0] "->includesâ‡©Sâ‡©eâ‡©t(" logic[0] ")"
    => "\<^const>UML_Set.OclIncludes" (1000)
  logic = logic[0] "->excludingâ‡©Sâ‡©eâ‡©t(" logic[0] ")"
    => "\<^const>UML_Set.OclExcluding" (1000)
  logic = logic[0] "->includingâ‡©Sâ‡©eâ‡©t(" logic[0] ")"
    => "\<^const>UML_Set.OclIncluding" (1000)
  logic = logic[36] "â‰¤â‡©râ‡©eâ‡©aâ‡©l" logic[36] => "\<^const>UML_Real.OclLeâ‡©Râ‡©eâ‡©aâ‡©l" (35)
  logic = logic[36] "<â‡©râ‡©eâ‡©aâ‡©l" logic[36] => "\<^const>UML_Real.OclLessâ‡©Râ‡©eâ‡©aâ‡©l"
    (35)
  logic = logic[46] "modâ‡©râ‡©eâ‡©aâ‡©l" logic[46]
    => "\<^const>UML_Real.OclModulusâ‡©Râ‡©eâ‡©aâ‡©l" (45)
  logic = logic[46] "divâ‡©râ‡©eâ‡©aâ‡©l" logic[46]
    => "\<^const>UML_Real.OclDivisionâ‡©Râ‡©eâ‡©aâ‡©l" (45)
  logic = logic[46] "*â‡©râ‡©eâ‡©aâ‡©l" logic[46] => "\<^const>UML_Real.OclMultâ‡©Râ‡©eâ‡©aâ‡©l"
    (45)
  logic = logic[42] "-â‡©râ‡©eâ‡©aâ‡©l" logic[42] => "\<^const>UML_Real.OclMinusâ‡©Râ‡©eâ‡©aâ‡©l"
    (41)
  logic = logic[41] "+â‡©râ‡©eâ‡©aâ‡©l" logic[41] => "\<^const>UML_Real.OclAddâ‡©Râ‡©eâ‡©aâ‡©l"
    (40)
  logic = logic[41] "+â‡©sâ‡©tâ‡©râ‡©iâ‡©nâ‡©g" logic[41]
    => "\<^const>UML_String.OclAddâ‡©Sâ‡©tâ‡©râ‡©iâ‡©nâ‡©g" (40)
  logic = logic[0] "->sumâ‡©Bâ‡©aâ‡©g()" => "\<^const>UML_Bag.OclSum" (1000)
  logic = logic[0] "->countâ‡©Bâ‡©aâ‡©g(" logic[0] ")" => "\<^const>UML_Bag.OclCount"
    (1000)
  logic = logic[0] "->intersectionâ‡©Bâ‡©aâ‡©g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIntersection" (1000)
  logic = logic[0] "->unionâ‡©Bâ‡©aâ‡©g(" logic[0] ")" => "\<^const>UML_Bag.OclUnion"
    (1000)
  logic = logic[0] "->excludesAllâ‡©Bâ‡©aâ‡©g(" logic[0] ")"
    => "\<^const>UML_Bag.OclExcludesAll" (1000)
  logic = logic[0] "->includesAllâ‡©Bâ‡©aâ‡©g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIncludesAll" (1000)
  logic = logic[0] "->rejectâ‡©Bâ‡©aâ‡©g(" id "|" logic[0] ")" => "_OclRejectBag" (1000)
  logic = logic[0] "->selectâ‡©Bâ‡©aâ‡©g(" id "|" logic[0] ")" => "_OclSelectBag" (1000)
  logic = logic[0] "->iterateâ‡©Bâ‡©aâ‡©g(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")"
    => "_OclIterateBag" (1000)
  logic = logic[0] "->existsâ‡©Bâ‡©aâ‡©g(" id "|" logic[0] ")" => "_OclExistBag" (1000)
  logic = logic[0] "->forAllâ‡©Bâ‡©aâ‡©g(" id "|" logic[0] ")" => "_OclForallBag" (1000)
  logic = logic[0] "->anyâ‡©Bâ‡©aâ‡©g()" => "\<^const>UML_Bag.OclANY" (1000)
  logic = logic[0] "->notEmptyâ‡©Bâ‡©aâ‡©g()" => "\<^const>UML_Bag.OclNotEmpty" (1000)
  logic = logic[0] "->isEmptyâ‡©Bâ‡©aâ‡©g()" => "\<^const>UML_Bag.OclIsEmpty" (1000)
  logic = logic[0] "->sizeâ‡©Bâ‡©aâ‡©g()" => "\<^const>UML_Bag.OclSize" (1000)
  logic = logic[0] "->excludesâ‡©Bâ‡©aâ‡©g(" logic[0] ")"
    => "\<^const>UML_Bag.OclExcludes" (1000)
  logic = logic[0] "->includesâ‡©Bâ‡©aâ‡©g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIncludes" (1000)
  logic = logic[0] "->excludingâ‡©Bâ‡©aâ‡©g(" logic[0] ")"
    => "\<^const>UML_Bag.OclExcluding" (1000)
  logic = logic[0] "->includingâ‡©Bâ‡©aâ‡©g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIncluding" (1000)
  logic = logic[36] "â‰¤â‡©iâ‡©nâ‡©t" logic[36]
    => "\<^const>UML_Integer.OclLeâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (35)
  logic = logic[36] "<â‡©iâ‡©nâ‡©t" logic[36]
    => "\<^const>UML_Integer.OclLessâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (35)
  logic = logic[46] "modâ‡©iâ‡©nâ‡©t" logic[46]
    => "\<^const>UML_Integer.OclModulusâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (45)
  logic = logic[46] "divâ‡©iâ‡©nâ‡©t" logic[46]
    => "\<^const>UML_Integer.OclDivisionâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (45)
  logic = logic[46] "*â‡©iâ‡©nâ‡©t" logic[46]
    => "\<^const>UML_Integer.OclMultâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (45)
  logic = logic[42] "-â‡©iâ‡©nâ‡©t" logic[42]
    => "\<^const>UML_Integer.OclMinusâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (41)
  logic = logic[41] "+â‡©iâ‡©nâ‡©t" logic[41]
    => "\<^const>UML_Integer.OclAddâ‡©Iâ‡©nâ‡©tâ‡©eâ‡©gâ‡©eâ‡©r" (40)
  logic = logic[0] ".Second()" => "\<^const>UML_Pair.OclSecond" (1000)
  logic = logic[0] ".First()" => "\<^const>UML_Pair.OclFirst" (1000)
  logic = logic[41] "<>" logic[41] => "notequal" (40)
  logic = logic[30] "â‰" logic[31] => "\<^const>UML_Logic.StrictRefEq" (30)
  logic = logic[0] "|â‰ " logic[0] => "OclNonValid" (50)
  logic = logic[0] "âŠ¨" logic[0] => "\<^const>UML_Logic.OclValid" (50)
  logic = logic[25] "implies" logic[26] => "\<^const>UML_Logic.OclImplies" (25)
  logic = logic[25] "or" logic[26] => "\<^const>UML_Logic.OclOr" (25)
  logic = logic[30] "and" logic[31] => "\<^const>UML_Logic.OclAnd" (30)
  logic = logic[30] "â‰œ" logic[31] => "\<^const>UML_Logic.StrongEq" (30)
  logic = logic[51] "has_real_derivative" logic[51]
    => "\<^const>Deriv.has_real_derivative" (50)
  logic = logic[51] "differentiable" logic[51] => "\<^const>Deriv.differentiable"
    (50)
  logic = logic[51] "has_vector_derivative" any[51]
    => "\<^const>Deriv.has_vector_derivative" (50)
  logic = logic[51] "has_field_derivative" any[51]
    => "\<^const>Deriv.has_field_derivative" (50)
  logic = logic[51] "has_derivative" logic[51] => "\<^const>Deriv.has_derivative"
    (50)
  logic = logic[81] "sums" any[80] => "\<^const>Series.sums" (80)
  logic = logic[76] "*â‡©R" any[75]
    => "\<^const>Real_Vector_Spaces.scaleR_class.scaleR" (75)
  logic = logic[60] "--" any[0] "-->" any[60] => "\<^const>Topological_Spaces.LIM"
    (60)
  logic = logic[60] "---->" any[60]
    => "\<^const>Topological_Spaces.topological_space_class.LIMSEQ" (60)
  logic = logic[56] "--->" any[55]
    => "\<^const>Topological_Spaces.topological_space_class.tendsto" (55)
  logic = logic[65] "choose" logic[66] => "\<^const>Binomial.binomial" (65)
  logic = logic[900] "(" Map.maplets[0] ")" => "_MapUpd" (900)
  logic = logic[51] "âŠ†â‡©m" logic[51] => "\<^const>Map.map_le" (50)
  logic = logic[110] "|`" logic[111] => "\<^const>Map.restrict_map" (110)
  logic = logic[100] "++" logic[101] => "\<^const>Map.map_add" (100)
  logic = logic[55] "âˆ˜â‡©m" logic[56] => "\<^const>Map.map_comp" (55)
  logic = logic[55] "o_m" logic[56] => "\<^const>Map.map_comp" (55)
  logic = logic[100] "!" logic[101] => "\<^const>List.nth" (100)
  logic = logic[66] "@" logic[65] => "\<^const>List.append" (65)
  logic = logic[81] "respects2" logic[80] => "\<^const>Equiv_Relations.RESPECTS2"
    (80)
  logic = logic[81] "respects" logic[80] => "\<^const>Equiv_Relations.RESPECTS"
    (80)
  logic = logic[90] "//" logic[91] => "\<^const>Equiv_Relations.quotient" (90)
  logic = logic[56] "initial_segment_of" logic[56]
    => "\<^const>Zorn.initialSegmentOf" (55)
  logic = logic[81] "<*mlex*>" logic[80] => "\<^const>Wellfounded.mlex_prod" (80)
  logic = logic[81] "<*lex*>" logic[80] => "\<^const>Wellfounded.lex_prod" (80)
  logic = logic[1000] "â‡§*â‡§*" => "\<^const>Transitive_Closure.rtranclp" (1000)
  logic = logic[1000] "â‡§+â‡§+" => "\<^const>Transitive_Closure.tranclp" (1000)
  logic = logic[1000] "â‡§=â‡§=" => "\<^const>Transitive_Closure.reflclp" (1000)
  logic = logic[1000] "â‡§*" => "\<^const>Transitive_Closure.rtrancl" (999)
  logic = logic[1000] "â‡§+" => "\<^const>Transitive_Closure.trancl" (999)
  logic = logic[1000] "â‡§=" => "\<^const>Transitive_Closure.reflcl" (999)
  logic = logic[1000] "^=" => "\<^const>Transitive_Closure.reflcl" (999)
  logic = logic[1000] "^==" => "\<^const>Transitive_Closure.reflclp" (1000)
  logic = logic[1000] "^**" => "\<^const>Transitive_Closure.rtranclp" (1000)
  logic = logic[1000] "^++" => "\<^const>Transitive_Closure.tranclp" (1000)
  logic = logic[1000] "^+" => "\<^const>Transitive_Closure.trancl" (999)
  logic = logic[1000] "^*" => "\<^const>Transitive_Closure.rtrancl" (999)
  logic = logic[91] "``" logic[90] => "\<^const>Relation.Image" (90)
  logic = logic[1000] "Â¯Â¯" => "\<^const>Relation.conversep" (1000)
  logic = logic[1000] "^--1" => "\<^const>Relation.conversep" (1000)
  logic = logic[1000] "Â¯" => "\<^const>Relation.converse" (999)
  logic = logic[1000] "^-1" => "\<^const>Relation.converse" (999)
  logic = logic[76] "OO" logic[75] => "\<^const>Relation.relcompp" (75)
  logic = logic[76] "O" logic[75] => "\<^const>Relation.relcomp" (75)
  logic = logic[66] "<+>" logic[65] => "\<^const>Sum_Type.Plus" (65)
  logic = logic[81] "Ã—" logic[80] => "\<^const>Product_Type.Times" (80)
  logic = logic[81] "<*>" logic[80] => "\<^const>Product_Type.Times" (80)
  logic = logic[55] "âˆ˜" logic[56] => "\<^const>Fun.comp" (55)
  logic = logic[55] "o" logic[56] => "\<^const>Fun.comp" (55)
  logic = logic[91] "-`" logic[90] => "\<^const>Set.vimage" (90)
  logic = logic[91] "`" logic[90] => "\<^const>Set.image" (90)
  logic = logic[65] "âˆª" logic[66] => "\<^const>Set.union" (65)
  logic = logic[65] "Un" logic[66] => "\<^const>Set.union" (65)
  logic = logic[70] "âˆ©" logic[71] => "\<^const>Set.inter" (70)
  logic = logic[70] "Int" logic[71] => "\<^const>Set.inter" (70)
  logic = logic[51] "âŠƒ" logic[51] => "\<^const>Set.supset" (50)
  logic = logic[51] "âŠ‡" logic[51] => "\<^const>Set.supset_eq" (50)
  logic = logic[51] "âŠ‚" logic[51] => "\<^const>Set.subset" (50)
  logic = logic[51] "âŠ†" logic[51] => "\<^const>Set.subset_eq" (50)
  logic = logic[26] "âŸ·" logic[25] => "\<^const>HOL.iff" (25)
  logic = logic[26] "<->" logic[25] => "\<^const>HOL.iff" (25)
  logic = logic[36] "âˆ§" logic[35] => "\<^const>HOL.conj" (35)
  logic = logic[31] "âˆ¨" logic[30] => "\<^const>HOL.disj" (30)
  logic = logic[26] "âŸ¶" logic[25] => "\<^const>HOL.implies" (25)
  logic = logic[36] "&" logic[35] => "\<^const>HOL.conj" (35)
  logic = logic[31] "|" logic[30] => "\<^const>HOL.disj" (30)
  logic = logic[26] "-->" logic[25] => "\<^const>HOL.implies" (25)
  logic = logic[4] "âˆ·" type[0] => "_constrain" (3)
  logic = logic[1000] cargs[1000] => "_applC" (999)
  logic = logic[4] "::" type[0] => "_constrain" (3)
  logic = any[81] "powr" any[80] => "\<^const>Transcendental.powr" (80)
  logic = any[70] "/â‡©R" logic[71]
    => "\<^const>Real_Vector_Spaces.scaleR_class.divideR" (70)
  logic = any[65] "gchoose" logic[66] => "\<^const>Binomial.gbinomial" (65)
  logic = any[900] "â¦‡" Record.field_updates[0] "â¦ˆ" => "_record_update" (900)
  logic = any[900] "(|" Record.field_updates[0] "|)" => "_record_update" (900)
  logic = any[900] "[" List.lupdbinds[0] "]" => "_LUpdate" (900)
  logic = any[66] "#" logic[65] => "\<^const>List.list.Cons" (65)
  logic = any[70] "mod" any[71] => "\<^const>Divides.div_class.mod" (70)
  logic = any[70] "div" any[71] => "\<^const>Divides.div_class.div" (70)
  logic = any[1000] "â‡§2" => "\<^const>Power.power_class.power2" (999)
  logic = any[81] "^" logic[80] => "\<^const>Power.power_class.power" (80)
  logic = any[81] "^^" logic[80] => "\<^const>Nat.compower" (80)
  logic = any[70] "/" any[71] => "\<^const>Fields.inverse_class.divide" (70)
  logic = any[51] "dvd" any[51] => "\<^const>Rings.dvd_class.dvd" (50)
  logic = any[1000] "(" Fun.updbinds[0] ")" => "_Update" (900)
  logic = any[51] "âˆˆ" logic[51] => "\<^const>Set.member" (50)
  logic = any[51] "âˆ‰" logic[51] => "\<^const>Set.not_member" (50)
  logic = any[51] "~:" logic[51] => "\<^const>Set.not_member" (50)
  logic = any[51] ":" logic[51] => "\<^const>Set.member" (50)
  logic = any[70] "*" any[71] => "\<^const>Groups.times_class.times" (70)
  logic = any[65] "-" any[66] => "\<^const>Groups.minus_class.minus" (65)
  logic = any[65] "+" any[66] => "\<^const>Groups.plus_class.plus" (65)
  logic = any[51] ">" any[51] => "\<^const>Orderings.ord_class.greater" (50)
  logic = any[51] "â‰¥" any[51] => "\<^const>Orderings.ord_class.greater_eq" (50)
  logic = any[51] ">=" any[51] => "\<^const>Orderings.ord_class.greater_eq" (50)
  logic = any[51] "â‰¤" any[51] => "\<^const>Orderings.ord_class.less_eq" (50)
  logic = any[51] "<=" any[51] => "\<^const>Orderings.ord_class.less_eq" (50)
  logic = any[51] "<" any[51] => "\<^const>Orderings.ord_class.less" (50)
  logic = any[50] "â‰ " any[51] => "\<^const>HOL.not_equal" (50)
  logic = any[50] "~=" any[51] => "\<^const>HOL.not_equal" (50)
  logic = any[50] "=" any[51] => "\<^const>HOL.eq" (50)
  logic = logic[0] ".allInstances()"
    => "\<^const>UML_State.OclAllInstances_at_post" (1000)
  logic = logic[0] ".allInstances@pre()"
    => "\<^const>UML_State.OclAllInstances_at_pre" (1000)
  logic = logic[0] ".oclIsNew()" => "\<^const>UML_State.OclIsNew" (1000)
  logic = logic[0] ".oclIsDeleted()" => "\<^const>UML_State.OclIsDeleted" (1000)
  logic = logic[0] ".oclIsMaintained()" => "\<^const>UML_State.OclIsMaintained"
    (1000)
  logic = logic[0] ".oclIsAbsent()" => "\<^const>UML_State.OclIsAbsent" (1000)
  logic = logic[0] "->oclIsModifiedOnly()"
    => "\<^const>UML_State.OclIsModifiedOnly" (1000)
  logic = logic[0] "@pre" logic[0] => "\<^const>UML_State.OclSelf_at_pre" (1000)
  logic = logic[0] "@post" logic[0] => "\<^const>UML_State.OclSelf_at_post" (1000)
  logic = var_position[-1] (-1)
  logic = longid_position[-1] (-1)
  logic = id_position[-1] (-1)
  longid_position = longid => "_position" (1000)
  num_const = num_position[0] => "_constify" (1000)
  num_position = num_token => "_position" (1000)
  prop = logic[0] => "\<^const>HOL.Trueprop" (5)
  prop = prop'[-1] (-1)
  prop' = "TERM" logic[0] => "\<^const>Pure.term" (1000)
  prop' = "SORT_CONSTRAINT" "(" type[0] ")" => "_sort_constraint" (1000)
  prop' = "OFCLASS" "(" type[0] "," logic[0] ")" => "_ofclass" (1000)
  prop' = "[|" asms[0] "|]" "==>" prop[1] => "_bigimpl" (1)
  prop' = "PROP" aprop[0] => "_aprop" (1000)
  prop' = "(" prop'[0] ")" (1000)
  prop' = "âŸ¦" asms[0] "âŸ§" "âŸ¹" prop[1] => "_bigimpl" (1)
  prop' = "â‹€" idts[0] "." prop[0] => "\<^const>Pure.all_binder" (0)
  prop' = "!!" idts[0] "." prop[0] => "\<^const>Pure.all_binder" (0)
  prop' = any[3] "==" any[3] => "\<^const>Pure.eq" (2)
  prop' = any[3] "â‰¡" any[3] => "\<^const>Pure.eq" (2)
  prop' = prop[2] "==>" prop[1] => "\<^const>Pure.imp" (1)
  prop' = prop[2] "âŸ¹" prop[1] => "\<^const>Pure.imp" (1)
  prop' = prop[3] "&&&" prop[2] => "\<^const>Pure.conjunction" (2)
  prop' = prop[2] "=simp=>" prop[1] => "\<^const>HOL.simp_implies" (1)
  prop' = prop'[4] "::" type[0] => "_constrain" (3)
  prop' = prop'[4] "âˆ·" type[0] => "_constrain" (3)
  pttrn = "(" pttrn[0] "," Product_Type.patterns[0] ")" => "_pattern" (1000)
  pttrn = idt[-1] (-1)
  pttrns = pttrn[1] pttrns[0] => "_pttrns" (0)
  pttrns = pttrn[-1] (-1)
  sort = "{" classes[0] "}" => "_sort" (1000)
  sort = "{}" => "_topsort" (1000)
  sort = class_name[-1] (-1)
  str_position = str_token => "_position" (1000)
  string_position = string_token => "_position" (1000)
  tid_position = tid => "_position_sort" (1000)
  tvar_position = tvar => "_position_sort" (1000)
  type = "_" => "\<^type>dummy" (1000)
  type = "_" "::" sort[0] => "_dummy_ofsort" (1000)
  type = "(" type[0] ")" (1000)
  type = "(" type[0] "," types[0] ")" type_name[0] => "_tappl" (1000)
  type = "[" types[0] "]" "=>" type[0] => "_bracket" (0)
  type = "[" types[0] "]" "â‡’" type[0] => "_bracket" (0)
  type = tvar_position[1000] "::" sort[0] => "_ofsort" (1000)
  type = tid_position[1000] "::" sort[0] => "_ofsort" (1000)
  type = tid_position[1000] "âˆ·" sort[0] => "_ofsort" (1000)
  type = "(|" Record.field_types[0] "," "..." "::" type[0] "|)"
    => "_record_type_scheme" (1000)
  type = "(|" Record.field_types[0] "|)" => "_record_type" (1000)
  type = "â¦‡" Record.field_types[0] "," "â€¦" "::" type[0] "â¦ˆ"
    => "_record_type_scheme" (1000)
  type = "â¦‡" Record.field_types[0] "â¦ˆ" => "_record_type" (1000)
  type = "âŸ¨" type[0] "âŸ©â‡©âŠ¥" => "\<^type>Option.option" (1000)
  type = "Pair(" type[0] "," type[0] ")" => "\<^type>UML_Types.Pairâ‡©bâ‡©aâ‡©sâ‡©e" (1000)
  type = "Set(" type[0] ")" => "\<^type>UML_Types.Setâ‡©bâ‡©aâ‡©sâ‡©e" (1000)
  type = "Bag(" type[0] ")" => "\<^type>UML_Types.Bagâ‡©bâ‡©aâ‡©sâ‡©e" (1000)
  type = "Sequence(" type[0] ")" => "\<^type>UML_Types.Sequenceâ‡©bâ‡©aâ‡©sâ‡©e" (1000)
  type = type[1] "â‡€" type[0] => "\<^type>Map.map" (0)
  type = type[1] "~=>" type[0] => "\<^type>Map.map" (0)
  type = type[11] "+" type[10] => "\<^type>Sum_Type.sum" (10)
  type = type[21] "Ã—" type[20] => "\<^type>Product_Type.prod" (20)
  type = type[21] "*" type[20] => "\<^type>Product_Type.prod" (20)
  type = type[1] "â‡’" type[0] => "\<^type>fun" (0)
  type = type[1000] type_name[0] => "_tapp" (1000)
  type = type[1] "=>" type[0] => "\<^type>fun" (0)
  type = type_name[-1] (-1)
  type = tvar_position[-1] (-1)
  type = tid_position[-1] (-1)
  type_name = longid => "_type_name" (1000)
  type_name = id => "_type_name" (1000)
  types = type[0] "," types[0] => "_types" (1000)
  types = type[-1] (-1)
  var_position = var => "_position" (1000)
print modes: "HOL" "HTML" "epsilon" "iff" "input" "latex" "latex_prod" "latex_sum"
  "xsymbols"
consts: "OclNonValid" "\<^const>Filter.Alm_all_binder"
  "\<^const>Filter.Inf_many_binder" "\<^const>HOL.All_binder"
  "\<^const>HOL.Ex1_binder" "\<^const>HOL.Ex_binder"
  "\<^const>Hilbert_Choice.Greatest_binder"
  "\<^const>Orderings.ord_class.Least_binder" "\<^const>Pure.all_binder"
  "\<^const>Series.suminf_binder" "_All_greater" "_All_greater_eq" "_All_less"
  "_All_less_eq" "_Ball" "_Bex" "_Bex1" "_Bleast" "_Char" "_Coll" "_Collect"
  "_Csum" "_DDDOT" "_Eps" "_Ex_greater" "_Ex_greater_eq" "_Ex_less" "_Ex_less_eq"
  "_Finset" "_Float" "_GreatestM" "_INF" "_INF1" "_INTER" "_INTER1" "_INTER_le"
  "_INTER_less" "_LIM" "_LUpdate" "_LeastM" "_Let" "_Map" "_MapUpd" "_Maplets"
  "_Numeral" "_OclCollectSeq" "_OclExistBag" "_OclExistSeq" "_OclExistSet"
  "_OclFinbag" "_OclFinsequence" "_OclFinset" "_OclForallBag" "_OclForallSeq"
  "_OclForallSet" "_OclIterateBag" "_OclIterateSeq" "_OclIterateSet"
  "_OclRejectBag" "_OclRejectSet" "_OclSelectBag" "_OclSelectSeq" "_OclSelectSet"
  "_SUP" "_SUP1" "_Setcompr" "_Sigma" "_String" "_TYPE" "_TYPEREP" "_The" "_UNION"
  "_UNION1" "_UNION_le" "_UNION_less" "_Update" "_abs" "_applC" "_aprop" "_args"
  "_asm" "_asms" "_bigimpl" "_bind" "_binds" "_bound" "_bracket" "_cargs"
  "_cartouche_oclstring" "_case1" "_case2" "_case_syntax" "_class_name" "_classes"
  "_constify" "_constrain" "_constrainAbs" "_context_const" "_context_xconst"
  "_dummy_ofsort" "_eventually" "_field" "_field_type" "_field_types"
  "_field_update" "_field_updates" "_fields" "_filter" "_free" "_frequently"
  "_from_to_setprod" "_from_to_setsum" "_from_upto_setprod" "_from_upto_setsum"
  "_idtdummy" "_idts" "_idtyp" "_idtypdummy" "_ignore_type" "_index"
  "_indexdefault" "_indexvar" "_inner_string" "_lam_pats_syntax" "_lambda"
  "_lc_abs" "_lc_end" "_lc_gen" "_lc_quals" "_lc_test" "_list" "_listcompr"
  "_listprod" "_listsum" "_loose" "_lupdbind" "_lupdbinds" "_maplet" "_maplets"
  "_mk_ofclass" "_numeral" "_ocl_denotation" "_ofclass" "_ofsort" "_pattern"
  "_patterns" "_position" "_position_sort" "_pttrns" "_qsetprod" "_qsetsum"
  "_record" "_record_scheme" "_record_type" "_record_type_scheme" "_record_update"
  "_setleAll" "_setleEx" "_setleEx1" "_setlessAll" "_setlessEx" "_setprod"
  "_setsum" "_sort" "_sort_constraint" "_strip_positions" "_struct" "_tapp"
  "_tappl" "_tfree" "_topsort" "_tuple" "_tuple_arg" "_tuple_args" "_tvar"
  "_type_constraint_" "_type_name" "_type_prop" "_types" "_update_name" "_updbind"
  "_updbinds" "_upt_setprod" "_upt_setsum" "_upto_setprod" "_upto_setsum" "_var"
  "notequal"
parse_ast_translation: "_Char" "_String" "_appl" "_applC" "_bigimpl" "_bracket"
  "_constify" "_context_const" "_context_xconst" "_idtyp" "_indexdefault"
  "_indexvar" "_lambda" "_strip_positions" "_struct" "_tapp" "_tappl"
parse_rules:
    ("_Bex" x A P)  ->  ("\<^const>Set.Bex" A ("_abs" x P))
    ("_Eps" x P)  ->  ("\<^const>Hilbert_Choice.Eps" ("_abs" x P))
    ("_INF" x A B)  ->
      ("\<^const>Complete_Lattices.Inf_class.INFIMUM" A ("_abs" x B))
    ("_LIM" x F1 f F2)  ->  ("\<^const>Filter.filterlim" ("_abs" x f) F2 F1)
    ("_Let" ("_binds" b bs) e)  ->  ("_Let" b ("_Let" bs e))
    ("_Let" ("_bind" x a) e)  ->  ("\<^const>HOL.Let" a ("_abs" x e))
    ("_Map" ms)  ->  ("_MapUpd" "\<^const>Map.empty" ms)
    ("_SUP" x A B)  ->
      ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" A ("_abs" x B))
    ("_The" x P)  ->  ("\<^const>HOL.The" ("_abs" x P))
    ("_abs" ("_pattern" x ("_patterns" y zs)) b)  ->
      ("\<^const>Product_Type.prod.case_prod"
        ("_abs" x ("_abs" ("_pattern" y zs) b)))
    ("_abs" ("_pattern" x y) b)  ->
      ("\<^const>Product_Type.prod.case_prod" ("_abs" x ("_abs" y b)))
    ("_abs" ("\<^const>Product_Type.Pair" x y) t)  ->  ("_abs" ("_pattern" x y) t)
    ("_Ball" x A P)  ->  ("\<^const>Set.Ball" A ("_abs" x P))
    ("_Bex1" x A P)  ->
      ("\<^const>HOL.Ex1_binder" x
        ("\<^const>HOL.conj" ("\<^const>Set.member" x A) P))
    ("_Coll" x P)  ->  ("\<^const>Set.Collect" ("_abs" x P))
    ("_Csum" i r rs)  ->  ("\<^const>BNF_Cardinal_Arithmetic.Csum" r ("_abs" i rs))
    ("_INF1" ("_pttrns" x y) B)  ->  ("_INF1" x ("_INF1" y B))
    ("_INF1" x B)  ->
      ("\<^const>Complete_Lattices.Inf_class.INFIMUM" "\<^const>Set.UNIV"
        ("_abs" x B))
    ("_INF1" x B)  ->  ("_INF" x "\<^const>Set.UNIV" B)
    ("_SUP1" ("_pttrns" x y) B)  ->  ("_SUP1" x ("_SUP1" y B))
    ("_SUP1" x B)  ->
      ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" "\<^const>Set.UNIV"
        ("_abs" x B))
    ("_SUP1" x B)  ->  ("_SUP" x "\<^const>Set.UNIV" B)
    ("_list" ("_args" x xs))  ->  ("\<^const>List.list.Cons" x ("_list" xs))
    ("_list" x)  ->  ("\<^const>List.list.Cons" x "\<^const>List.list.Nil")
    ("_INTER" x A B)  ->  ("\<^const>Complete_Lattices.INTER" A ("_abs" x B))
    ("_Sigma" x A B)  ->  ("\<^const>Product_Type.Sigma" A ("_abs" x B))
    ("_UNION" x A B)  ->  ("\<^const>Complete_Lattices.UNION" A ("_abs" x B))
    ("_tuple" x ("_tuple_arg" y))  ->  ("\<^const>Product_Type.Pair" x y)
    ("_tuple" x ("_tuple_args" y z))  ->
      ("_tuple" x ("_tuple_arg" ("_tuple" y z)))
    ("_Bleast" x A P)  ->
      ("\<^const>Orderings.ord_class.Least_binder" x
        ("\<^const>HOL.conj" ("\<^const>Set.member" x A) P))
    ("_Finset" ("_args" x xs))  ->  ("\<^const>Set.insert" x ("_Finset" xs))
    ("_Finset" x)  ->  ("\<^const>Set.insert" x "\<^const>Set.empty")
    ("_INTER1" ("_pttrns" x y) B)  ->  ("_INTER1" x ("_INTER1" y B))
    ("_INTER1" x B)  ->
      ("\<^const>Complete_Lattices.INTER" "\<^const>Set.UNIV" ("_abs" x B))
    ("_INTER1" x B)  ->  ("_INTER" x "\<^const>Set.UNIV" B)
    ("_LeastM" x m P)  ->  ("\<^const>Hilbert_Choice.LeastM" m ("_abs" x P))
    ("_MapUpd" m ("_maplets" x y))  ->  ("\<^const>Map.map_upds" m x y)
    ("_MapUpd" m ("_Maplets" xy ms))  ->  ("_MapUpd" ("_MapUpd" m xy) ms)
    ("_MapUpd" m ("_maplet" x y))  ->
      ("_Update" m ("_updbind" x ("\<^const>Option.option.Some" y)))
    ("_UNION1" ("_pttrns" x y) B)  ->  ("_UNION1" x ("_UNION1" y B))
    ("_UNION1" x B)  ->
      ("\<^const>Complete_Lattices.UNION" "\<^const>Set.UNIV" ("_abs" x B))
    ("_UNION1" x B)  ->  ("_UNION" x "\<^const>Set.UNIV" B)
    ("_Update" f ("_updbinds" b bs))  ->  ("_Update" ("_Update" f b) bs)
    ("_Update" f ("_updbind" x y))  ->  ("\<^const>Fun.fun_upd" f x y)
    ("_filter" x xs P)  ->  ("\<^const>List.filter" ("_abs" x P) xs)
    ("_setsum" i A b)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i b) A)
    ("_Collect" p A P)  ->
      ("\<^const>Set.Collect"
        ("_abs" p ("\<^const>HOL.conj" ("\<^const>Set.member" p A) P)))
    ("_Ex_less" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.less" x y) P))
    ("_LUpdate" xs ("_lupdbinds" b bs))  ->  ("_LUpdate" ("_LUpdate" xs b) bs)
    ("_LUpdate" xs ("_lupdbind" i x))  ->  ("\<^const>List.list_update" xs i x)
    ("_listsum" x xs b)  ->
      ("\<^const>Groups_List.monoid_add_class.listsum"
        ("\<^const>List.list.map" ("_abs" x b) xs))
    ("_pattern" x y)  ->  ("\<^const>Product_Type.Pair" x y)
    ("_qsetsum" x P t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
        ("_Coll" x P))
    ("_setleEx" A B P)  ->
      ("\<^const>HOL.Ex_binder" A
        ("\<^const>HOL.conj" ("\<^const>Set.subset_eq" A B) P))
    ("_setprod" i A b)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i b) A)
    ("notequal" a b)  ->
      ("\<^const>UML_Logic.OclNot" ("\<^const>UML_Logic.StrictRefEq" a b))
    ("_All_less" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.less" x y) P))
    ("_INTER_le" i n A)  ->
      ("_INTER" i ("\<^const>Set_Interval.ord_class.atMost" n) A)
    ("_UNION_le" i n A)  ->
      ("_UNION" i ("\<^const>Set_Interval.ord_class.atMost" n) A)
    ("_listprod" x xs b)  ->
      ("\<^const>Groups_List.monoid_mult_class.listprod"
        ("\<^const>List.list.map" ("_abs" x b) xs))
    ("_patterns" x y)  ->  ("\<^const>Product_Type.Pair" x y)
    ("_qsetprod" x P t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
        ("_Coll" x P))
    ("_setleAll" A B P)  ->
      ("\<^const>HOL.All_binder" A
        ("\<^const>HOL.implies" ("\<^const>Set.subset_eq" A B) P))
    ("_setleEx1" A B P)  ->
      ("\<^const>HOL.Ex1_binder" A
        ("\<^const>HOL.conj" ("\<^const>Set.subset_eq" A B) P))
    ("_GreatestM" x m P)  ->  ("\<^const>Hilbert_Choice.GreatestM" m ("_abs" x P))
    ("_OclFinbag" ("_args" x xs))  ->
      ("\<^const>UML_Bag.OclIncluding" ("_OclFinbag" xs) x)
    ("_OclFinbag" x)  ->
      ("\<^const>UML_Bag.OclIncluding" "\<^const>UML_Bag.mtBag" x)
    ("_OclFinset" ("_args" x xs))  ->
      ("\<^const>UML_Set.OclIncluding" ("_OclFinset" xs) x)
    ("_OclFinset" x)  ->
      ("\<^const>UML_Set.OclIncluding" "\<^const>UML_Set.mtSet" x)
    ("_setlessEx" A B P)  ->
      ("\<^const>HOL.Ex_binder" A
        ("\<^const>HOL.conj" ("\<^const>Set.subset" A B) P))
    ("OclNonValid" Ï„ P)  ->
      ("\<^const>HOL.Not" ("\<^const>UML_Logic.OclValid" Ï„ P))
    ("_Ex_greater" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.greater" x y) P))
    ("_Ex_less_eq" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.less_eq" x y) P))
    ("_INTER_less" i n A)  ->
      ("_INTER" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)
    ("_UNION_less" i n A)  ->
      ("_UNION" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)
    ("_eventually" x F P)  ->  ("\<^const>Filter.eventually" ("_abs" x P) F)
    ("_frequently" x F P)  ->  ("\<^const>Filter.frequently" ("_abs" x P) F)
    ("_setlessAll" A B P)  ->
      ("\<^const>HOL.All_binder" A
        ("\<^const>HOL.implies" ("\<^const>Set.subset" A B) P))
    ("_upt_setsum" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.lessThan" n))
    ("_All_greater" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.greater" x y) P))
    ("_All_less_eq" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.less_eq" x y) P))
    ("_OclExistBag" X x P)  ->  ("\<^const>UML_Bag.OclExists" X ("_abs" x P))
    ("_OclExistSeq" X x P)  ->  ("\<^const>UML_Sequence.OclExists" X ("_abs" x P))
    ("_OclExistSet" X x P)  ->  ("\<^const>UML_Set.OclExists" X ("_abs" x P))
    ("_upt_setprod" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.lessThan" n))
    ("_upto_setsum" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.atMost" n))
    ("_OclForallBag" X x P)  ->  ("\<^const>UML_Bag.OclForall" X ("_abs" x P))
    ("_OclForallSeq" X x P)  ->  ("\<^const>UML_Sequence.OclForall" X ("_abs" x P))
    ("_OclForallSet" X x P)  ->  ("\<^const>UML_Set.OclForall" X ("_abs" x P))
    ("_OclRejectBag" X x P)  ->  ("\<^const>UML_Bag.OclReject" X ("_abs" x P))
    ("_OclRejectSet" X x P)  ->  ("\<^const>UML_Set.OclReject" X ("_abs" x P))
    ("_OclSelectBag" X x P)  ->  ("\<^const>UML_Bag.OclSelect" X ("_abs" x P))
    ("_OclSelectSeq" X x P)  ->  ("\<^const>UML_Sequence.OclSelect" X ("_abs" x P))
    ("_OclSelectSet" X x P)  ->  ("\<^const>UML_Set.OclSelect" X ("_abs" x P))
    ("_upto_setprod" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.atMost" n))
    ("_Ex_greater_eq" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.greater_eq" x y) P))
    ("_OclCollectSeq" X x P)  ->
      ("\<^const>UML_Sequence.OclCollect" X ("_abs" x P))
    ("_OclIterateBag" X a x A P)  ->
      ("\<^const>UML_Bag.OclIterate" X A ("_abs" a ("_abs" x P)))
    ("_OclIterateSeq" X a x A P)  ->
      ("\<^const>UML_Sequence.OclIterate" X A ("_abs" a ("_abs" x P)))
    ("_OclIterateSet" X a x A P)  ->
      ("\<^const>UML_Set.OclIterate" X A ("_abs" a ("_abs" x P)))
    ("_All_greater_eq" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.greater_eq" x y) P))
    ("_OclFinsequence" ("_args" x xs))  ->
      ("\<^const>UML_Sequence.OclPrepend" ("_OclFinsequence" xs) x)
    ("_OclFinsequence" x)  ->
      ("\<^const>UML_Sequence.OclPrepend" "\<^const>UML_Sequence.mtSequence" x)
    ("_from_to_setsum" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))
    ("_from_to_setprod" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))
    ("_from_upto_setsum" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))
    ("_from_upto_setprod" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))
parse_translation: "\<^const>Filter.Alm_all_binder"
  "\<^const>Filter.Inf_many_binder" "\<^const>HOL.All_binder"
  "\<^const>HOL.Ex1_binder" "\<^const>HOL.Ex_binder"
  "\<^const>Hilbert_Choice.Greatest_binder"
  "\<^const>Orderings.ord_class.Least_binder" "\<^const>Pure.all_binder"
  "\<^const>Series.suminf_binder" "_DDDOT" "_Float" "_Numeral" "_Setcompr" "_TYPE"
  "_TYPEREP" "_abs" "_aprop" "_cartouche_oclstring" "_case_syntax" "_index"
  "_lam_pats_syntax" "_listcompr" "_ofclass" "_record" "_record_scheme"
  "_record_type" "_record_type_scheme" "_record_update" "_sort_constraint"
  "_struct" "_update_name"
print_translation: "\<^const>Complete_Lattices.INTER"
  "\<^const>Complete_Lattices.Inf_class.INFIMUM"
  "\<^const>Complete_Lattices.Sup_class.SUPREMUM"
  "\<^const>Complete_Lattices.UNION" "\<^const>Ctr_Sugar.case_guard"
  "\<^const>Filter.Alm_all" "\<^const>Filter.Inf_many"
  "\<^const>Groups.one_class.one" "\<^const>Groups.zero_class.zero"
  "\<^const>Groups_Big.comm_monoid_add_class.setsum" "\<^const>HOL.All"
  "\<^const>HOL.All_binder" "\<^const>HOL.Ex" "\<^const>HOL.Ex1"
  "\<^const>HOL.Ex_binder" "\<^const>HOL.The" "\<^const>Hilbert_Choice.Eps"
  "\<^const>Hilbert_Choice.Greatest" "\<^const>Num.numeral_class.numeral"
  "\<^const>Orderings.ord_class.Least" "\<^const>Product_Type.prod.case_prod"
  "\<^const>Pure.all" "\<^const>Pure.type" "\<^const>Series.suminf"
  "\<^const>Set.Ball" "\<^const>Set.Bex" "\<^const>Set.Collect"
  "\<^const>Typerep.typerep_class.typerep" "\<^const>UML_Types.state.assocs_update"
  "\<^const>UML_Types.state.heap_update" "\<^const>UML_Types.state.more_update"
  "\<^const>UML_Types.state.state_ext" "\<^type>UML_Types.state.state_ext"
  "_type_constraint_" "_type_prop"
print_rules:
    ("_INF" x "\<^const>Set.UNIV" B)  ->  ("_INF1" x B)
    ("_Let" b ("_Let" bs e))  ->  ("_Let" ("_binds" b bs) e)
    ("_SUP" x "\<^const>Set.UNIV" B)  ->  ("_SUP1" x B)
    ("_INF1" x ("_INF1" y B))  ->  ("_INF1" ("_pttrns" x y) B)
    ("_SUP1" x ("_SUP1" y B))  ->  ("_SUP1" ("_pttrns" x y) B)
    ("_INTER" i ("\<^const>Set_Interval.ord_class.atMost" n) A)  ->
      ("_INTER_le" i n A)
    ("_INTER" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)  ->
      ("_INTER_less" i n A)
    ("_INTER" x "\<^const>Set.UNIV" B)  ->  ("_INTER1" x B)
    ("_UNION" i ("\<^const>Set_Interval.ord_class.atMost" n) A)  ->
      ("_UNION_le" i n A)
    ("_UNION" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)  ->
      ("_UNION_less" i n A)
    ("_UNION" x "\<^const>Set.UNIV" B)  ->  ("_UNION1" x B)
    ("_tuple" x ("_tuple_arg" ("_tuple" y z)))  ->
      ("_tuple" x ("_tuple_args" y z))
    ("_INTER1" x ("_INTER1" y B))  ->  ("_INTER1" ("_pttrns" x y) B)
    ("_MapUpd" ("_MapUpd" m xy) ms)  ->  ("_MapUpd" m ("_Maplets" xy ms))
    ("_MapUpd" "\<^const>Map.empty" ms)  ->  ("_Map" ms)
    ("_MapUpd" ("_Map" ms1) ms2)  ->  ("_Map" ("_Maplets" ms1 ms2))
    ("_UNION1" x ("_UNION1" y B))  ->  ("_UNION1" ("_pttrns" x y) B)
    ("_Update" m ("_updbind" x ("\<^const>Option.option.Some" y)))  ->
      ("_MapUpd" m ("_maplet" x y))
    ("_Update" ("_Update" f b) bs)  ->  ("_Update" f ("_updbinds" b bs))
    ("_LUpdate" ("_LUpdate" xs b) bs)  ->  ("_LUpdate" xs ("_lupdbinds" b bs))
    ("_Maplets" ("_Maplets" ms1 ms2) ms3)  ->
      ("_Maplets" ms1 ("_Maplets" ms2 ms3))
    ("\<^const>HOL.Let" a ("_abs" x e))  ->  ("_Let" ("_bind" x a) e)
    ("\<^const>HOL.Not" ("\<^const>UML_Logic.OclValid" Ï„ P))  ->
      ("OclNonValid" Ï„ P)
    ("\<^const>HOL.The" ("_abs" x P))  ->  ("_The" x P)
    ("\<^const>Set.Bex" A ("_abs" x P))  ->  ("_Bex" x A P)
    ("\<^const>Set.Ball" A ("_abs" x P))  ->  ("_Ball" x A P)
    ("\<^const>Set.insert" x ("_Finset" xs))  ->  ("_Finset" ("_args" x xs))
    ("\<^const>Set.insert" x "\<^const>Set.empty")  ->  ("_Finset" x)
    ("\<^const>Fun.fun_upd" f x y)  ->  ("_Update" f ("_updbind" x y))
    ("\<^const>List.filter" ("_abs" x P) xs)  ->  ("_filter" x xs P)
    ("\<^const>Set.Collect" ("_abs" x P))  ->  ("_Coll" x P)
    ("\<^const>Map.map_upds" m x y)  ->  ("_MapUpd" m ("_maplets" x y))
    ("\<^const>HOL.not_equal" ("\<^const>Set.range" f) "\<^const>Set.UNIV")  ->
      ("\<^const>HOL.Not" ("\<^const>Fun.surj" f))
    ("\<^const>List.list.Cons" x ("_list" xs))  ->  ("_list" ("_args" x xs))
    ("\<^const>List.list.Cons" x "\<^const>List.list.Nil")  ->  ("_list" x)
    ("\<^const>Filter.filterlim" ("_abs" x f) F2 F1)  ->  ("_LIM" x F1 f F2)
    ("\<^const>List.list_update" xs i x)  ->  ("_LUpdate" xs ("_lupdbind" i x))
    ("\<^const>UML_Logic.OclNot" ("\<^const>UML_Logic.StrictRefEq" a b))  ->
      ("notequal" a b)
    ("\<^const>Filter.eventually" ("_abs" x P) F)  ->  ("_eventually" x F P)
    ("\<^const>Filter.frequently" ("_abs" x P) F)  ->  ("_frequently" x F P)
    ("\<^const>Product_Type.Pair" x y)  ->  ("_tuple" x ("_tuple_arg" y))
    ("\<^const>UML_Bag.OclExists" X ("_abs" x P))  ->  ("_OclExistBag" X x P)
    ("\<^const>UML_Bag.OclForall" X ("_abs" x P))  ->  ("_OclForallBag" X x P)
    ("\<^const>UML_Bag.OclReject" X ("_abs" x P))  ->  ("_OclRejectBag" X x P)
    ("\<^const>UML_Bag.OclSelect" X ("_abs" x P))  ->  ("_OclSelectBag" X x P)
    ("\<^const>UML_Set.OclExists" X ("_abs" x P))  ->  ("_OclExistSet" X x P)
    ("\<^const>UML_Set.OclForall" X ("_abs" x P))  ->  ("_OclForallSet" X x P)
    ("\<^const>UML_Set.OclReject" X ("_abs" x P))  ->  ("_OclRejectSet" X x P)
    ("\<^const>UML_Set.OclSelect" X ("_abs" x P))  ->  ("_OclSelectSet" X x P)
    ("\<^const>Hilbert_Choice.Eps" ("_abs" x P))  ->  ("_Eps" x P)
    ("\<^const>Product_Type.Sigma" A ("_abs" x B))  ->  ("_Sigma" x A B)
    ("\<^const>UML_Bag.OclIterate" X A ("_abs" a ("_abs" x P)))  ->
      ("_OclIterateBag" X a x A P)
    ("\<^const>UML_Set.OclIterate" X A ("_abs" a ("_abs" x P)))  ->
      ("_OclIterateSet" X a x A P)
    ("\<^const>UML_Bag.OclIncluding" ("_OclFinbag" xs) x)  ->
      ("_OclFinbag" ("_args" x xs))
    ("\<^const>UML_Bag.OclIncluding" "\<^const>UML_Bag.mtBag" x)  ->
      ("_OclFinbag" x)
    ("\<^const>UML_Set.OclIncluding" ("_OclFinset" xs) x)  ->
      ("_OclFinset" ("_args" x xs))
    ("\<^const>UML_Set.OclIncluding" "\<^const>UML_Set.mtSet" x)  ->
      ("_OclFinset" x)
    ("\<^const>Hilbert_Choice.LeastM" m ("_abs" x P))  ->  ("_LeastM" x m P)
    ("\<^const>UML_Sequence.OclExists" X ("_abs" x P))  ->  ("_OclExistSeq" X x P)
    ("\<^const>UML_Sequence.OclForall" X ("_abs" x P))  ->  ("_OclForallSeq" X x P)
    ("\<^const>UML_Sequence.OclSelect" X ("_abs" x P))  ->  ("_OclSelectSeq" X x P)
    ("\<^const>Complete_Lattices.INTER" "\<^const>Set.UNIV" ("_abs" x B))  ->
      ("_INTER1" x B)
    ("\<^const>Complete_Lattices.INTER" A ("_abs" x B))  ->  ("_INTER" x A B)
    ("\<^const>Complete_Lattices.UNION" "\<^const>Set.UNIV" ("_abs" x B))  ->
      ("_UNION1" x B)
    ("\<^const>Complete_Lattices.UNION" A ("_abs" x B))  ->  ("_UNION" x A B)
    ("\<^const>UML_Sequence.OclCollect" X ("_abs" x P))  ->
      ("_OclCollectSeq" X x P)
    ("\<^const>UML_Sequence.OclIterate" X A ("_abs" a ("_abs" x P)))  ->
      ("_OclIterateSeq" X a x A P)
    ("\<^const>UML_Sequence.OclPrepend" ("_OclFinsequence" xs) x)  ->
      ("_OclFinsequence" ("_args" x xs))
    ("\<^const>UML_Sequence.OclPrepend" "\<^const>UML_Sequence.mtSequence" x)  ->
      ("_OclFinsequence" x)
    ("\<^const>Hilbert_Choice.GreatestM" m ("_abs" x P))  ->  ("_GreatestM" x m P)
    ("\<^const>Product_Type.prod.case_prod"
      ("_abs" x ("_abs" ("_pattern" y zs) b)))  ->
      ("_abs" ("_pattern" x ("_patterns" y zs)) b)
    ("\<^const>Product_Type.prod.case_prod" ("_abs" x ("_abs" y b)))  ->
      ("_abs" ("_pattern" x y) b)
    ("\<^const>BNF_Cardinal_Arithmetic.Csum" r ("_abs" i rs))  ->  ("_Csum" i r rs)
    ("\<^const>Complete_Lattices.Inf_class.INFIMUM" "\<^const>Set.UNIV"
      ("_abs" x B))  ->
      ("_INF1" x B)
    ("\<^const>Complete_Lattices.Inf_class.INFIMUM" A ("_abs" x B))  ->
      ("_INF" x A B)
    ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" "\<^const>Set.UNIV"
      ("_abs" x B))  ->
      ("_SUP1" x B)
    ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" A ("_abs" x B))  ->
      ("_SUP" x A B)
    ("\<^const>Groups_List.monoid_add_class.listsum"
      ("\<^const>List.list.map" ("_abs" x b) xs))  ->
      ("_listsum" x xs b)
    ("\<^const>Groups_List.monoid_mult_class.listprod"
      ("\<^const>List.list.map" ("_abs" x b) xs))  ->
      ("_listprod" x xs b)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))  ->
      ("_from_to_setsum" x a b t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))  ->
      ("_from_upto_setsum" x a b t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.atMost" n))  ->
      ("_upto_setsum" i n t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.lessThan" n))  ->
      ("_upt_setsum" i n t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i b) A)  ->
      ("_setsum" i A b)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))  ->
      ("_from_to_setprod" x a b t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))  ->
      ("_from_upto_setprod" x a b t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.atMost" n))  ->
      ("_upto_setprod" i n t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.lessThan" n))  ->
      ("_upt_setprod" i n t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i b) A)  ->
      ("_setprod" i A b)
print_ast_translation: "\<^const>Pure.imp" "\<^const>String.char.Char"
  "\<^type>fun" "_abs" "_idts" "_index" "_list" "_pttrns" "_struct"